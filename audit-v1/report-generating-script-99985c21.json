{
  "schemaVersion": "2.0.0",
  "id": "99985c21-896d-4723-9522-f9c95279c6ee",
  "title": "Report Generating Script",
  "status": "EDITABLE",
  "version": null,
  "previousVersion": null,
  "metadata": {
    "index": "0",
    "createdAt": "1970-01-01T00:00:00.000Z",
    "lastUpdatedAt": "1970-01-01T00:00:00.000Z",
    "createdByRoleId": "44444444-4444-4444-4444-444444444444",
    "lastUpdatedByRoleId": "44444444-4444-4444-4444-444444444444",
    "editors": [],
    "typeIndex": "0"
  },
  "sourceInfo": {},
  "fields": {},
  "kind": "INSTANCE",
  "type": {
    "ref": {
      "id": "191b63bc-1863-4174-ac39-8e6d51e3d4e4"
    }
  },
  "content": {
    "type": "SCRIPT_CODE",
    "value": {
      "scriptCode": "import pandas as pd\nimport uuid\n\n# --- Configuration ---\n# Name of the template to create an instance of (the Audit Report Form template)\nAUDIT_REPORT_TEMPLATE_NAME = \"Audit Report Form\"\n\n# Names of the ONLY reference fields in the containing entity\n# whose referenced entities should be collated into the report, IN THIS EXACT ORDER.\nREFERENCE_FIELDS_TO_COLLATE = [\n    \"Internal Audit Notification\",\n    \"Meeting Summary Form\",\n    \"Question and Response Log\",\n    \"Evidence Request Form\",\n    \"Audit Findings Log\",\n    \"CAPA Form\",\n    \"Root Cause Analysis Form\",\n    \"CAPA Effectiveness Review Form\",\n    \"Audit Completion Form\",\n]\n\n# Names of the non-reference fields from the CONTAINING entity\n# that should be included at the top of the report, IN THIS EXACT ORDER.\nTOP_LEVEL_FIELDS_TO_INCLUDE = [\n    \"Start Date\",\n    \"Lead Auditor\",\n    \"Other Auditors\",\n    \"Purpose of Audit\",\n    \"Description and Scope of Audit\",\n    \"Summary of Audit\",\n    # \"SOP\", # SOP is a REFERENCE field, handled below if included in REFERENCE_FIELDS_TO_COLLATE\n]\n\n\n# Name of the reference field in the containing entity\n# where the newly created Audit Report Form instance should be linked.\nAUDIT_REPORT_LINK_FIELD_NAME = \"Audit Report Form\"\n\n# Name of the reference field in the NEW Audit Report instance\n# that should link back to the containing Audit Checklist entity.\nAUDIT_MASTER_DOCUMENT_FIELD_NAME = \"Audit Master Document\"\n\n# Prefix for top-level fields added to the report to ensure clarity and uniqueness\n# Removed prefix, will use original names\n# TOP_LEVEL_FIELD_PREFIX = \"Audit Info - \"\n\n\n# --- Helper Function to map Seal dataType to Seal field type string for API/seal.add_field ---\ndef map_data_type_to_field_type_string(dataType):\n    \"\"\"Maps Seal dataType string to the string used for field 'type' in API/add_field.\"\"\"\n    mapping = {\n        \"STRING\": \"STRING\",\n        \"NUMBER\": \"NUMBER\",\n        \"BOOLEAN\": \"BOOLEAN\",\n        \"DATE\": \"DATE\",\n        \"DATETIME\": \"DATETIME\",\n        \"SELECT\": \"SELECT\",\n        \"ENTITY\": \"REFERENCE\",\n        \"ROLE\": \"USER\", # ROLE dataType maps to USER field type\n        \"UPLOAD\": \"REFERENCE\", # UPLOAD dataType maps to REFERENCE field type when creating a new field\n        # FORMULA and INSTANCE_SUBMISSION are not typically added dynamically this way,\n        # but include for completeness based on API spec enums.\n        \"FORMULA\": \"FORMULA\",\n        \"INSTANCE_SUBMISSION\": \"INSTANCE_SUBMISSION\",\n    }\n    return mapping.get(dataType, \"STRING\") # Default to STRING if unknown\n\n# --- Recursive function to copy page content blocks and generate new UUIDs ---\ndef copy_and_re_uuid_block(block, source_entity_id, source_field_id_to_target_field_id_map):\n    \"\"\"\n    Recursively copies a page content block, assigns new UUIDs, and updates fieldIds.\n    Skips field blocks if the source field is not mapped to a field in the target entity.\n    \"\"\"\n    if not isinstance(block, dict):\n        return block # Return non-dict elements directly (like text runs)\n\n    new_block = block.copy()\n    # Generate a new UUID for the block itself\n    new_block['id'] = str(uuid.uuid4())\n\n    # Handle field blocks specifically\n    if new_block.get('type') == 'field' and 'fieldId' in block:\n        original_field_id = block['fieldId']\n        map_key = (source_entity_id, original_field_id)\n\n        if map_key in source_field_id_to_target_field_id_map:\n            # Source field was successfully mapped and added to the target entity.\n            # Update the fieldId in the copied block to the new target field ID.\n            new_block['fieldId'] = source_field_id_to_target_field_id_map[map_key]\n            # Preserve entityPreview if it existed, or add if target is UPLOAD\n            # The main loop's check for UPLOAD dataType when creating the field is more reliable for entityPreview,\n            # but copying existing config here doesn't hurt.\n            if 'entityPreview' in block:\n                 new_block['entityPreview'] = block['entityPreview'].copy()\n\n            # The children of a field block are usually just a single text block, copy recursively\n            # Pass None for source_entity_id and empty map for recursive calls\n            # as child blocks like text runs don't have fields themselves.\n            # Only the top-level 'field' block needs the mapping.\n            if 'children' in new_block and isinstance(new_block['children'], list):\n                 new_children = []\n                 for child in new_block['children']:\n                      copied_child = copy_and_re_uuid_block(child, None, {}) # Recursive call\n                      if copied_child is not None:\n                          new_children.append(copied_child)\n                 new_block['children'] = new_children\n            # If no children, add a default empty text child\n            elif 'children' not in new_block or not new_block['children']:\n                 new_block['children'] = [{\"text\": \"\"}]\n\n\n        else:\n            # If the source field ID doesn't map to a target field ID,\n            # this field was not included in the fields copied to the report.\n            # Return None to indicate this block should be skipped.\n            # The calling code that iterates through copied_blocks will filter out None.\n            # print(f\"Info: Source field ID '{original_field_id}' from entity '{source_entity_id}' not found in target mapping. Skipping field block.\") # Optional: keep log for debugging\n            return None # Skip this block entirely\n\n\n    # Recursively copy children for non-field blocks\n    elif 'children' in new_block and isinstance(new_block['children'], list):\n        new_children = []\n        for child in new_block['children']:\n            # Pass source_entity_id and map down the recursive call\n            copied_child = copy_and_re_uuid_block(child, source_entity_id, source_field_id_to_target_field_id_map)\n            if copied_child is not None: # Only add if it wasn't skipped (returning None)\n                new_children.append(copied_child)\n        new_block['children'] = new_children\n\n    # Keep specific data for other block types (taskData for 'task', etc.)\n    if new_block.get('type') == 'task' and 'taskData' in block:\n         new_block['taskData'] = block['taskData'].copy() # Copy taskData\n\n    # Add other specific block types data copying here if needed (e.g., 'image', 'codeblock', 'table', 'tr', 'td')\n    # The recursive children copy handles the structure for tables (tr, td).\n\n    return new_block\n\n\n# --- Helper Function to get a unique field name ---\ndef get_unique_field_name(base_name, existing_names_set):\n    \"\"\"Appends _N to a base name until it is unique in the set.\"\"\"\n    new_name = base_name\n    counter = 1\n    while new_name in existing_names_set:\n        new_name = f\"{base_name}_{counter}\"\n        counter += 1\n    return new_name\n\n\n# --- Main Script Logic ---\n\n# 1. Get the containing entity (the Audit Checklist instance)\ncontaining_entity = seal.get_containing_entity()\ncontaining_entity_id = containing_entity.get(\"id\")\ncontaining_fields = containing_entity.get(\"fields\", {})\ncontaining_entity_title = containing_entity.get(\"title\", containing_entity_id)\n\nprint(f\"Processing Audit Checklist instance: {containing_entity_title}\")\n\n# 2. Check if an Audit Report entity is already linked\nreport_entity_id = None\naudit_report_link_field = containing_fields.get(AUDIT_REPORT_LINK_FIELD_NAME)\n\nif audit_report_link_field and audit_report_link_field.get(\"value\"):\n    current_refs = audit_report_link_field[\"value\"]\n    if current_refs and isinstance(current_refs, list) and len(current_refs) > 0:\n        # Assuming the link field is single-value, take the first reference\n        linked_report_ref = current_refs[0]\n        linked_report_id = linked_report_ref.get(\"id\")\n        if linked_report_id:\n            try:\n                # Verify the linked entity exists and is an instance\n                linked_entity = seal.get_entity(linked_report_id)\n                if linked_entity.get(\"kind\") == \"INSTANCE\":\n                    report_entity_id = linked_report_id\n                    print(f\"Found existing linked Audit Report instance: {report_entity_id}. Will update this entity.\")\n                else:\n                    print(f\"Warning: Linked entity {linked_report_id} is not an instance or does not exist. Will create a new report.\")\n            except Exception as e:\n                print(f\"Warning: Could not fetch linked entity {linked_report_id}: {e}. Will create a new report.\")\n        else:\n             print(f\"Warning: Found invalid reference in '{AUDIT_REPORT_LINK_FIELD_NAME}'. Will create a new report.\")\n    else:\n        print(f\"No existing linked Audit Report instance found in '{AUDIT_REPORT_LINK_FIELD_NAME}'. Will create a new report.\")\nelse:\n    print(f\"Reference field '{AUDIT_REPORT_LINK_FIELD_NAME}' is empty or does not exist. Will create a new report.\")\n\n\n# 3. If no existing report was found, create a new one\nif report_entity_id is None:\n    print(\"Creating a new Audit Report instance...\")\n    audit_report_template_id = None\n    try:\n        search_query = {\n            \"filters\": {\n                \"kind\": [\"TEMPLATE\"],\n                \"text\": [AUDIT_REPORT_TEMPLATE_NAME]\n            }\n        }\n        templates = seal.search_entities(search_query)\n        if templates:\n            # Assuming the first result is the correct template\n            audit_report_template_id = templates[0][\"id\"]\n            print(f\"Found '{AUDIT_REPORT_TEMPLATE_NAME}' template with ID: {audit_report_template_id}\")\n        else:\n            raise Exception(f\"Template '{AUDIT_REPORT_TEMPLATE_NAME}' not found.\")\n    except Exception as e:\n        seal.throw_error(f\"Error finding template '{AUDIT_REPORT_TEMPLATE_NAME}': {e}\")\n\n    try:\n        # Construct the desired title\n        new_report_title = f\"Audit Report - {containing_entity_title}\"\n\n        # Create the instance with the specified title\n        new_report_instance = seal.create_instance_from_template(\n            template_id=audit_report_template_id,\n            title=new_report_title # Set the custom title here\n        )\n        report_entity_id = new_report_instance[\"id\"]\n        print(f\"Created new '{AUDIT_REPORT_TEMPLATE_NAME}' instance with ID: {report_entity_id} and title '{new_report_title}'\")\n\n        # Populate the 'Audit Master Document' field in the new instance\n        try:\n            # The value for a REFERENCE field is a list of reference objects\n            containing_entity_ref_value = [{\"id\": containing_entity_id, \"version\": None}] # version=None for latest\n\n            seal.update_field_value_in_entity(\n                entity_id=report_entity_id,\n                field_name=AUDIT_MASTER_DOCUMENT_FIELD_NAME,\n                field_value=containing_entity_ref_value\n            )\n            print(f\"Populated '{AUDIT_MASTER_DOCUMENT_FIELD_NAME}' field in new instance {report_entity_id} with reference to containing entity {containing_entity_id}.\")\n\n        except Exception as e:\n            print(f\"Warning: Could not populate '{AUDIT_MASTER_DOCUMENT_FIELD_NAME}' field in new instance {report_entity_id}: {e}\")\n            # Continue execution, as populating this field might not be strictly critical\n            # depending on template configuration.\n\n        # Link the new entity back to the containing entity\n        try:\n            # Ensure the containing entity is editable\n            # This should not happen if the script is run from an action button on it.\n            # However, adding this check makes the script more robust.\n            containing_entity_reloaded = seal.get_entity(containing_entity_id) # Re-fetch to ensure it's editable\n            if containing_entity_reloaded[\"status\"] != \"EDITABLE\":\n                 print(f\"Containing entity {containing_entity_id} is not editable. Making it editable.\")\n                 seal.make_entity_editable(containing_entity_id)\n                 # Need to re-fetch entity again to get the editable version\n                 containing_entity_reloaded = seal.get_entity(containing_entity_id)\n                 containing_fields = containing_entity_reloaded.get(\"fields\", {}) # Re-get fields\n\n            audit_report_link_field_reloaded = containing_fields.get(AUDIT_REPORT_LINK_FIELD_NAME) # Re-get field info\n\n            if audit_report_link_field_reloaded:\n                # Get current references in the link field (should be empty if it was just created)\n                current_refs = audit_report_link_field_reloaded.get(\"value\") or []\n\n                # Add the new entity's reference\n                new_ref = {\"id\": report_entity_id, \"version\": None} # Link to the latest version (draft)\n\n                allow_multiple = audit_report_link_field_reloaded.get(\"config\", {}).get(\"allowMultiple\", False)\n\n                if allow_multiple:\n                     # Check if the reference already exists to avoid duplicates\n                     if not any(r[\"id\"] == new_ref[\"id\"] for r in current_refs):\n                         updated_refs = current_refs + [new_ref]\n                     else:\n                         updated_refs = current_refs\n                         print(f\"New Audit Report instance {report_entity_id} is already linked.\")\n                else:\n                    # If single value only, replace the current value\n                    updated_refs = [new_ref]\n\n                # Only update if the list of references has actually changed\n                if updated_refs != current_refs: # Check if modification is needed\n                    seal.update_field_value_in_entity(\n                        entity_id=containing_entity_id,\n                        field_name=AUDIT_REPORT_LINK_FIELD_NAME,\n                        field_value=updated_refs\n                    )\n                    print(f\"Linked new Audit Report instance {report_entity_id} to field '{AUDIT_REPORT_LINK_FIELD_NAME}' in containing entity.\")\n                else:\n                     print(f\"Audit Report instance {report_entity_id} is already correctly linked.\")\n\n            else:\n                 print(f\"Warning: Reference field '{AUDIT_REPORT_LINK_FIELD_NAME}' not found in containing entity. Cannot link report back.\")\n\n        except Exception as e:\n            print(f\"Error linking new instance {report_entity_id} back to containing entity {containing_entity_id}: {e}\")\n            # This error is less critical, don't necessarily throw a hard error that stops the script\n            # unless linking is a mandatory part of the process. Let's just print a warning.\n\n\n    except Exception as e:\n        seal.throw_error(f\"Error creating new instance of '{AUDIT_REPORT_TEMPLATE_NAME}': {e}\")\n\n\n# 4. Ensure the target report entity is editable and CLEAN UP existing fields and content\nif report_entity_id:\n    try:\n        # Re-fetch the target entity to ensure we have the latest draft and its fields/content\n        report_entity = seal.get_entity(report_entity_id)\n\n        if report_entity[\"status\"] != \"EDITABLE\":\n            print(f\"Audit Report instance {report_entity_id} is not editable. Making it editable.\\n\")\n            # make_entity_editable returns the new draft, so we should use that\n            report_entity = seal.make_entity_editable(report_entity_id)\n            print(f\"Entity {report_entity_id} is now editable.\")\n\n        # --- Clean up Existing Fields ---\n        print(f\"\\nCleaning up existing fields in report instance {report_entity_id}...\")\n        # Re-fetch fields after making editable in case new draft has different fields\n        current_report_fields = seal.get_entity(report_entity_id).get(\"fields\", {})\n        fields_to_delete = []\n        for field_name, field_info in current_report_fields.items():\n            # Keep the Audit Master Document back-reference field\n            if field_name != AUDIT_MASTER_DOCUMENT_FIELD_NAME:\n                fields_to_delete.append(field_name)\n\n        if fields_to_delete:\n            print(f\"Deleting {len(fields_to_delete)} fields: {', '.join(fields_to_delete)}\")\n            for field_name in fields_to_delete:\n                 try:\n                     # Use the Seal module method for deleting fields\n                     seal.delete_field_in_entity(report_entity_id, field_name)\n                     print(f\"Deleted field: '{field_name}'\")\n                 except Exception as delete_e:\n                     print(f\"Warning: Failed to delete field '{field_name}': {delete_e}\")\n            # Re-fetch the entity after deleting fields to update existing_field_names set later\n            report_entity = seal.get_entity(report_entity_id)\n            print(\"Field cleanup complete.\")\n        else:\n            print(\"No non-back-reference fields found to delete.\")\n\n\n        # --- Clean up Existing Page Content ---\n        print(f\"\\nCleaning up existing page content in report instance {report_entity_id}...\")\n        # Re-fetch content after making editable\n        current_content = seal.get_entity(report_entity_id).get(\"content\", {})\n\n        if current_content.get(\"type\") == \"PAGE_CONTENT\":\n            current_page_content = current_content.get(\"value\", {}).get(\"pageContent\")\n            if current_page_content:\n                try:\n                    # Use seal._request to patch the content directly\n                    seal._request(\n                        url=f\"entities/{report_entity_id}/content\",\n                        method=\"PATCH\",\n                        json={\n                            \"content\": {\n                                \"type\": \"PAGE_CONTENT\",\n                                \"value\": {\n                                    \"pageContent\": [] # Empty array to clear content\n                                }\n                            }\n                        }\n                    )\n                    print(\"Cleared existing page content.\")\n                except Exception as content_patch_e:\n                    print(f\"Warning: Failed to clear page content: {content_patch_e}\")\n            else:\n                print(\"Page content is already empty.\")\n        else:\n            print(\"Entity does not have PAGE_CONTENT or content is empty.\")\n\n    except Exception as e:\n        seal.throw_error(f\"Error during cleanup phase for Audit Report instance {report_entity_id}: {e}\")\n\n\n# 5. Add fields from referenced entities and top-level fields to the target Audit Report entity\nif report_entity_id:\n    print(f\"\\nAdding fields to report instance {report_entity_id}...\")\n    # Re-fetch the report entity AGAIN to get its *current* fields after cleanup\n    report_entity = seal.get_entity(report_entity_id)\n    existing_field_names = set(report_entity.get(\"fields\", {}).keys())\n\n    # Collect data from referenced entities including page content and field info, preserving order\n    collated_entity_data = []\n\n    # New: Track top-level field mappings for page content generation\n    # Structure: [(original_field_name, target_field_name), ...]\n    top_level_field_mappings_ordered = []\n\n    # New: Map original source field IDs to target field IDs for page content copying\n    source_field_id_to_target_field_id_map = {}\n    # Map source entity ID to its source field ID -> target field ID map\n    source_entity_id_to_field_map = {}\n\n\n    # --- Process Top-Level Fields from Containing Entity ---\n    print(\"Processing top-level fields from containing entity...\")\n    containing_source_field_map = {} # Map source field ID to target field name for this entity\n    source_entity_id_to_field_map[containing_entity_id] = containing_source_field_map\n\n    for field_name in TOP_LEVEL_FIELDS_TO_INCLUDE:\n        field_info = containing_fields.get(field_name)\n        if field_info and field_name != AUDIT_REPORT_LINK_FIELD_NAME:\n            source_dataType = field_info.get(\"dataType\")\n            # Skip reference and script fields, and fields with no dataType\n            if source_dataType is None or source_dataType in [\"ENTITY\", \"SCRIPT\"]:\n                 if source_dataType is not None:\n                     print(f\"Warning: Skipping field '{field_name}' from containing entity as it is a {source_dataType}.\")\n                 else:\n                     print(f\"Warning: Skipping field '{field_name}' from containing entity as it has no dataType.\")\n                 continue\n\n            # Use the original field name as the target field name\n            target_field_name = field_name\n\n            # Check if a field with this name already exists on the report template (unlikely after cleanup, but safe check)\n            if target_field_name in existing_field_names:\n                print(f\"Warning: Field name '{target_field_name}' from containing entity conflicts with an existing field in the report template. Skipping.\")\n                continue # Skip this field to avoid conflict\n\n            # Add the new unique name to our set for future checks within THIS script run\n            existing_field_names.add(target_field_name)\n\n            # Map the source dataType to the target field type string\n            target_field_type_string = map_data_type_to_field_type_string(source_dataType)\n\n            # Extract other field properties and format value\n            target_field_value = field_info.get(\"value\")\n\n            # Value formatting similar to referenced entities section\n            if source_dataType == \"SELECT\":\n                 if isinstance(target_field_value, str):\n                     target_field_value = [target_field_value]\n                 elif not isinstance(target_field_value, list):\n                     target_field_value = None\n                 if isinstance(target_field_value, list):\n                      # Ensure list items are strings, handling None gracefully\n                      target_field_value = [str(item) for item in target_field_value if isinstance(item, (str, int, float, bool))]\\\n                                           if target_field_value is not None else None # Handle None list\n                      if target_field_value is not None and not target_field_value: target_field_value = None\n\n\n            target_allow_multiple = field_info.get(\"config\", {}).get(\"allowMultiple\", False)\n            target_select_options = field_info.get(\"config\", {}).get(\"selectOptions\")\n            target_multi_line = field_info.get(\"config\", {}).get(\"multiLine\", False)\n            target_formula_expression = field_info.get(\"config\", {}).get(\"formulaExpression\")\n\n\n            try:\n                # Add the new field to the target Audit Report entity using the API\n                print(f\"Attempting to add top-level field '{target_field_name}' (Type: {target_field_type_string}, DataType: {source_dataType}) to {report_entity_id}...\")\n\n                field_payload = {\n                    \"fieldName\": target_field_name,\n                    \"type\": target_field_type_string,\n                    \"value\": target_field_value,\n                }\n\n                # Add config properties based on type\n                if \"allowMultiple\" in field_info.get(\"config\", {}):\n                     field_payload[\"allowMultiple\"] = target_allow_multiple\n                if target_field_type_string == \"SELECT\" and \"selectOptions\" in field_info.get(\"config\", {}):\n                     field_payload[\"selectOptions\"] = target_select_options\n                if target_field_type_string == \"STRING\" and \"multiLine\" in field_info.get(\"config\", {}):\n                     field_payload[\"multiLine\"] = target_multi_line\n                if target_field_type_string == \"FORMULA\" and \"formulaExpression\" in field_info.get(\"config\", {}):\n                     field_payload[\"formulaExpression\"] = target_formula_expression\n\n\n                seal._request(\n                    url=f\"entities/{report_entity_id}/fields\",\n                    method=\"POST\",\n                    json=field_payload\n                )\n                print(f\"Successfully added top-level field '{target_field_name}'.\")\n\n                # Track successful field creation for page content generation\n                top_level_field_mappings_ordered.append((field_name, target_field_name))\n\n                # Map source field ID to target field name for page content copying\n                containing_source_field_map[field_info.get(\"id\")] = target_field_name\n\n\n            except Exception as add_field_e:\n                print(f\"Warning: Failed to add top-level field '{target_field_name}' to entity {report_entity_id}. Error: {add_field_e}. Payload: {field_payload}\\n\")\n                # Continue processing other fields even if one fails\n        else:\n            print(f\"Warning: Top-level field '{field_name}' not found in containing entity.\")\n\n\n    # --- Process Fields and Content from Referenced Entities ---\n    print(\"\\nProcessing fields and content from referenced entities...\")\n    # Iterate directly over the REFERENCE_FIELDS_TO_COLLATE list to ensure order\n    for field_name in REFERENCE_FIELDS_TO_COLLATE:\n        ref_field = containing_fields.get(field_name)\n        if ref_field and ref_field.get(\"value\"):\n            referenced_entities_refs = ref_field[\"value\"]\n            print(f\"Processing entities in '{field_name}' ({len(referenced_entities_refs)} entities)....\\n\")\n\n            if referenced_entities_refs:\n                for ref in referenced_entities_refs:\n                    try:\n                        # Fetch the referenced entity\n                        # Use get_entity with ref object to handle version\n                        referenced_entity = seal.get_entity(ref=ref)\n                        source_entity_id = referenced_entity.get(\"id\") # Get source entity ID\n                        source_entity_title = referenced_entity.get(\"title\", source_entity_id)\n                        print(f\"Processing entity: {source_entity_title} (ID: {source_entity_id})\")\n\n\n                        source_fields = referenced_entity.get(\"fields\", {})\n                        source_content = referenced_entity.get(\"content\", {})\n\n                        current_entity_field_mappings = [] # Store mappings for this specific source entity\n                        current_source_field_map = {} # Map source field ID to target field name for this entity\n                        source_entity_id_to_field_map[source_entity_id] = current_source_field_map\n\n\n                        if source_fields:\n                            for source_field_name, source_field_info in source_fields.items():\n                                # Skip the back-reference field to the Audit Master Document\n                                if source_field_name == AUDIT_MASTER_DOCUMENT_FIELD_NAME:\n                                     continue\n\n                                # Determine a unique field name for the target entity\n                                # Prefix with the source entity title (sanitized) to make names more descriptive\n                                sanitized_source_title = \"\".join(c if c.isalnum() or c in (' ', '-', '_') else '' for c in source_entity_title).strip()\n                                # Ensure title is not empty after sanitization\n                                if not sanitized_source_title:\n                                    sanitized_source_title = \"Entity\" # Fallback if title is weird\n                                base_target_field_name = f\"{sanitized_source_title} - {source_field_name}\"\n                                target_field_name = get_unique_field_name(base_target_field_name, existing_field_names)\n\n                                # Add the new unique name to our set for future checks within THIS script run\n                                existing_field_names.add(target_field_name)\n\n                                # Map the source dataType to the target field type string\n                                source_dataType = source_field_info.get(\"dataType\")\n                                if source_dataType is None:\n                                     print(f\"Warning: Field '{source_field_name}' in entity {source_entity_title} has no dataType. Skipping field.\")\n                                     continue # Skip fields with no dataType\n\n                                target_field_type_string = map_data_type_to_field_type_string(source_dataType)\n\n                                # Extract other field properties and format value\n                                target_field_value = source_field_info.get(\"value\")\n\n                                if source_dataType == \"ENTITY\": # Source is a REFERENCE or INSTANCE_SUBMISSION\n                                     if isinstance(target_field_value, dict) and \"id\" in target_field_value:\n                                         target_field_value = [target_field_value]\n                                     elif isinstance(target_field_value, list):\n                                         target_field_value = [item for item in target_field_value if isinstance(item, dict) and \"id\" in item]\n                                         if not target_field_value: target_field_value = None\n                                     else:\n                                         target_field_value = None\n                                elif source_dataType == \"UPLOAD\": # Source is an UPLOAD (File reference)\n                                     pass # Keep target_field_value as is\n                                elif source_dataType == \"SELECT\":\n                                     if isinstance(target_field_value, str):\n                                         target_field_value = [target_field_value]\n                                     elif not isinstance(target_field_value, list):\n                                         target_field_value = None\n                                     if isinstance(target_field_value, list):\n                                          target_field_value = [str(item) for item in target_field_value if isinstance(item, (str, int, float, bool))]\n                                          if not target_field_value: target_field_value = None\n\n\n                                target_allow_multiple = source_field_info.get(\"config\", {}).get(\"allowMultiple\", False)\n                                target_select_options = source_field_info.get(\"config\", {}).get(\"selectOptions\")\n                                target_multi_line = source_field_info.get(\"config\", {}).get(\"multiLine\", False)\n                                target_formula_expression = source_field_info.get(\"config\", {}).get(\"formulaExpression\")\n\n\n                                try:\n                                    # Add the new field to the target Audit Report entity using the API\n                                    print(f\"Attempting to add field '{target_field_name}' (Type: {target_field_type_string}, DataType: {source_dataType}) to {report_entity_id}...\")\n\n                                    field_payload = {\n                                        \"fieldName\": target_field_name,\n                                        \"type\": target_field_type_string,\n                                        \"value\": target_field_value,\n                                    }\n\n                                    # Add config properties based on type, matching API schema where possible\n                                    # Check if the config key exists in the source field_info\n                                    if \"allowMultiple\" in source_field_info.get(\"config\", {}):\n                                         field_payload[\"allowMultiple\"] = target_allow_multiple\n                                    if target_field_type_string == \"SELECT\" and \"selectOptions\" in source_field_info.get(\"config\", {}):\n                                         field_payload[\"selectOptions\"] = target_select_options\n                                    if target_field_type_string == \"STRING\" and \"multiLine\" in source_field_info.get(\"config\", {}):\n                                         field_payload[\"multiLine\"] = target_multi_line\n                                    if target_field_type_string == \"FORMULA\" and \"formulaExpression\" in source_field_info.get(\"config\", {}):\n                                         field_payload[\"formulaExpression\"] = target_formula_expression\n\n\n                                    # Use seal._request to add the field\n                                    # This is preferred over seal.add_field for full control over the payload\n                                    seal._request(\n                                        url=f\"entities/{report_entity_id}/fields\",\n                                        method=\"POST\",\n                                        json=field_payload\n                                    )\n                                    print(f\"Successfully added field '{target_field_name}'.\")\n\n                                    # Track successful field creation for page content generation\n                                    # Store source field name, target field name, and source dataType\n                                    current_entity_field_mappings.append((source_field_name, target_field_name, source_dataType))\n\n                                    # Map source field ID to target field name for page content copying\n                                    current_source_field_map[source_field_info.get(\"id\")] = target_field_name\n\n\n                                except Exception as add_field_e:\n                                    print(f\"Warning: Failed to add field '{target_field_name}' to entity {report_entity_id}. Error: {add_field_e}. Payload: {field_payload}\")\n                                    # Continue processing other fields even if one fails\n\n\n                        else:\n                            print(f\"No standard fields found in entity {source_entity_title}.\\n\")\n\n                        # Collect page content blocks from the source entity\n                        source_page_content_blocks = []\n                        if source_content.get(\"type\") == \"PAGE_CONTENT\":\n                            source_page_content_blocks = source_content.get(\"value\", {}).get(\"pageContent\", [])\n                            print(f\"Collected {len(source_page_content_blocks)} page content blocks from entity {source_entity_title}.\\n\")\n                        else:\n                             print(f\"Entity {source_entity_title} does not have PAGE_CONTENT or content is empty.\\n\")\n\n\n                        # Store collected data for this entity\n                        collated_entity_data.append({\n                            \"source_entity_id\": source_entity_id, # Store source entity ID\n                            \"entity_title\": source_entity_title,\n                            \"page_content_blocks\": source_page_content_blocks,\n                            \"field_mappings\": current_entity_field_mappings, # List of (source_field_name, target_field_name, source_dataType)\n                        })\n\n                    except Exception as e:\n                        print(f\"Warning: Failed to fetch or process referenced entity {ref.get('id', 'N/A')}: {e}\\n\")\n                        # Continue processing other entities even if one fails\n\n            else:\n                 print(f\"No entities linked in '{field_name}'.\\n\")\n\n        else:\n            # Add a message if the expected reference field doesn't exist in the containing entity\n            print(f\"Reference field '{field_name}' does not exist in containing entity or is empty.\\n\")\n\n\nelse:\n    print(\"No Audit Report entity found or created. Cannot add fields or content.\")\n\n\n# 6. Generate page content with top-level fields, entity headings, field references, and copied content\nif report_entity_id and (top_level_field_mappings_ordered or collated_entity_data):\n    print(f\"\\nGenerating page content for report instance {report_entity_id}...\")\n\n    try:\n        # Re-fetch the target entity to get the actual field IDs after adding all fields\n        updated_report_entity = seal.get_entity(report_entity_id)\n        report_fields = updated_report_entity.get(\"fields\", {})\n\n        # Final mapping from source field ID to target field ID for page content copying\n        source_field_id_to_target_field_id_map = {}\n        for source_entity_id, source_field_map in source_entity_id_to_field_map.items():\n             for source_field_id, target_field_name in source_field_map.items():\n                  target_field_info = report_fields.get(target_field_name)\n                  if target_field_info and target_field_info.get(\"id\"):\n                       source_field_id_to_target_field_id_map[(source_entity_id, source_field_id)] = target_field_info[\"id\"]\n\n\n        # Generate page content blocks for the report\n        page_content_blocks = []\n\n        # --- Add Top-Level Fields to Page Content ---\n        if top_level_field_mappings_ordered:\n            # Removed heading for top-level fields\n\n            # Add field elements for each top-level field\n            for i, (original_field_name, target_field_name) in enumerate(top_level_field_mappings_ordered):\n                 field_info = report_fields.get(target_field_name)\n                 if field_info and field_info.get(\"id\"):\n                     field_block = {\n                         \"id\": str(uuid.uuid4()),\n                         \"type\": \"field\",\n                         \"fieldId\": field_info[\"id\"], # Use the actual field ID\n                         \"children\": [{\"text\": \"\"}]\n                     }\n                     page_content_blocks.append(field_block)\n\n                     # Add spacing *between* fields, but not after the last one\n                     if i < len(top_level_field_mappings_ordered) - 1:\n                         spacing_block = {\n                             \"id\": str(uuid.uuid4()),\n                             \"type\": \"p\",\n                             \"children\": [{\"text\": \"\"}]\n                         }\n                         page_content_blocks.append(spacing_block)\n                 else:\n                     print(f\"Warning: Top-level field '{target_field_name}' not found in updated entity or missing ID. Cannot add to page content.\")\n\n            # Add extra spacing after the top-level section if any fields were added\n            if top_level_field_mappings_ordered: # Check if any top-level blocks were added\n                 section_spacing_block = {\n                     \"id\": str(uuid.uuid4()),\n                     \"type\": \"p\",\n                     \"children\": [{\"text\": \"\"}]\n                 }\n                 page_content_blocks.append(section_spacing_block)\n\n\n        # --- Add Referenced Entity Content and Fields to Page Content ---\n        # Iterate through the collected data for referenced entities (already ordered)\n        for entity_data in collated_entity_data:\n            source_entity_id = entity_data[\"source_entity_id\"] # Get source entity ID\n            entity_title = entity_data[\"entity_title\"]\n            source_page_content_blocks = entity_data[\"page_content_blocks\"]\n            field_mappings = entity_data[\"field_mappings\"] # This is a list of (source_field_name, target_field_name, source_dataType)\n\n            # Add entity title as h2 heading if there's content or fields from this entity\n            # Only add heading if there is actual content or fields to display from this entity\n            if field_mappings or source_page_content_blocks:\n                heading_block = {\n                    \"id\": str(uuid.uuid4()),\n                    \"type\": \"h2\",\n                    \"children\": [{\"text\": entity_title}]\n                }\n                page_content_blocks.append(heading_block)\n\n            # Add copied page content blocks from the source entity\n            if source_page_content_blocks:\n                 print(f\"Copying {len(source_page_content_blocks)} content blocks from entity {entity_title}...\")\n                 # Pass source_entity_id and the field ID mapping to the recursive copy function\n                 copied_blocks = [copy_and_re_uuid_block(block, source_entity_id, source_field_id_to_target_field_id_map) for block in source_page_content_blocks]\n                 # Filter out any blocks that were replaced by None during copying\n                 copied_blocks = [block for block in copied_blocks if block is not None]\n                 page_content_blocks.extend(copied_blocks)\n                 print(f\"Added {len(copied_blocks)} copied blocks.\")\n\n\n            # Add extra spacing after this entity's section if content/fields were added\n            if field_mappings or source_page_content_blocks: # Check if anything was added for this entity\n                 section_spacing_block = {\n                     \"id\": str(uuid.uuid4()),\n                     \"type\": \"p\",\n                     \"children\": [{\"text\": \"\"}]\n                 }\n                 page_content_blocks.append(section_spacing_block)\n\n\n        # Update the entity's page content using the API\n        if page_content_blocks:\n            seal._request(\n                url=f\"entities/{report_entity_id}/content\",\n                method=\"PATCH\",\n                json={\n                    \"content\": {\n                        \"type\": \"PAGE_CONTENT\",\n                        \"value\": {\n                            \"pageContent\": page_content_blocks\n                        }\n                    }\n                }\n            )\n            print(f\"\\nSuccessfully updated page content with {len(page_content_blocks)} total content blocks\")\n            print(f\"Generated content for {len(top_level_field_mappings_ordered)} top-level fields and collated data from {len(collated_entity_data)} referenced entities.\")\n        else:\n            print(\"\\nNo page content blocks to add\")\n\n    except Exception as e:\n        print(f\"\\nError generating page content: {e}\")\n        # Don't fail the whole script if page content generation fails\n\nelif report_entity_id:\n    print(\"\\nNo fields or content were successfully collated, skipping page content generation\")\nelse:\n    print(\"\\nNo report entity available for page content generation\")\n\n\nprint(\"\\nScript finished.\")"
    }
  }
}
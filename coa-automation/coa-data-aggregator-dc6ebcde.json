{
  "schemaVersion": "2.0.0",
  "id": "dc6ebcde-55b6-4e9e-973d-c970b0825685",
  "title": "COA Data Aggregator",
  "status": "EDITABLE",
  "version": null,
  "previousVersion": null,
  "metadata": {
    "index": "0",
    "createdAt": "1970-01-01T00:00:00.000Z",
    "lastUpdatedAt": "1970-01-01T00:00:00.000Z",
    "createdByRoleId": "44444444-4444-4444-4444-444444444444",
    "lastUpdatedByRoleId": "44444444-4444-4444-4444-444444444444",
    "editors": [],
    "typeIndex": "0"
  },
  "sourceInfo": {},
  "fields": {},
  "kind": "INSTANCE",
  "type": {
    "ref": {
      "id": "66a14f85-37ab-434b-84ef-6bfd54f8b4cd"
    }
  },
  "content": {
    "type": "SCRIPT_CODE",
    "value": {
      "scriptCode": "import pandas as pd\nimport json # Import json for easier debugging if needed\n\n# Helper function to extract text from a content block (like a table cell)\ndef extract_text_from_content(content_block):\n    text = \"\"\n    if isinstance(content_block, dict):\n        if \"text\" in content_block:\n            text += content_block[\"text\"]\n        if \"children\" in content_block:\n            for child in content_block[\"children\"]:\n                text += extract_text_from_content(child)\n    elif isinstance(content_block, list):\n        for item in content_block:\n            text += extract_text_from_content(item)\n    return text.strip()\n\n# Helper function to safely convert a value to float\ndef safe_float_conversion(value_str):\n    if value_str is None or value_str == \"\":\n        return None\n    try:\n        # Attempt to convert to float, handling potential commas as decimal separators\n        # (though '4.5' suggests dot is the separator, robust check)\n        return float(str(value_str).replace(',', '.'))\n    except (ValueError, TypeError):\n        print(f\"Warning: Could not convert value '{value_str}' to a number.\")\n        return None\n\n\n# Get the containing CoA instance entity\ncoa_instance = seal.get_containing_entity()\n\n# --- Get Referenced Entities ---\n\n# Get the Batch reference field value\nbatch_ref_field = coa_instance[\"fields\"].get(\"Batch\")\nbatch_ref_value = batch_ref_field.get(\"value\") if batch_ref_field else None\n\n# Get the Product Specification reference field value\nspec_ref_field = coa_instance[\"fields\"].get(\"Product Specification\")\nspec_ref_value = spec_ref_field.get(\"value\") if spec_ref_field else None\n\n# Check if required reference fields are populated\nif not batch_ref_value or not spec_ref_value:\n    print(\"Error: 'Batch' and/or 'Product Specification' reference fields are not populated.\")\n    exit()\n\n# Assuming single references based on template config (allowMultiple: false)\nbatch_entity_id = batch_ref_value[0][\"id\"]\nspec_entity_id = spec_ref_value[0][\"id\"]\n\nprint(f\"Retrieving Batch entity with ID: {batch_entity_id}\")\nprint(f\"Retrieving Product Specification entity with ID: {spec_entity_id}\")\n\n# Get the referenced entities\n# Use get_entity for Batch (likely a completable record, get latest)\n# Use get_entity_active_version for Product Specification (likely a versioned document, get active)\nbatch_entity = seal.get_entity(entity_id=batch_entity_id)\ntry:\n    spec_entity = seal.get_entity_active_version(entity_id=spec_entity_id)\nexcept Exception as e:\n    print(f\"Error retrieving active version of Product Specification entity: {e}\")\n    print(\"Please ensure the referenced Product Specification has a published active version.\")\n    exit()\n\nif not batch_entity or not spec_entity:\n    print(\"Error: Could not retrieve Batch or Product Specification entity data.\")\n    exit()\n\nbatch_fields = batch_entity.get(\"fields\", {})\nspec_content = spec_entity.get(\"content\", {}).get(\"value\", {}).get(\"pageContent\", [])\n\nprint(\"\\nProcessing data...\")\n\n# --- Extract Limits from Product Specification Table ---\nspec_limits_list = [] # Use a list to maintain order\ntable_found = False\n\n# Iterate through content blocks to find the table\nfor block in spec_content:\n    if block.get(\"type\") == \"table\" and \"children\" in block:\n        table_found = True\n        rows = block[\"children\"]\n        if not rows:\n            print(\"Warning: Found an empty table in Product Specification content.\")\n            break # Stop processing this table\n\n        # Assume the first row is the header\n        header_row = rows[0]\n        if header_row.get(\"type\") != \"tr\" or \"children\" not in header_row:\n             print(\"Warning: First table element is not a row or has no children.\")\n             break # Skip this table\n\n        headers = [extract_text_from_content(cell) for cell in header_row[\"children\"]]\n\n        # Find column indices for Lower Limit and Upper Limit\n        try:\n            lower_limit_col_idx = headers.index(\"Lower Limit\")\n            upper_limit_col_idx = headers.index(\"Upper Limit\")\n            print(f\"Found table headers: {headers}\")\n        except ValueError as e:\n            print(f\"Warning: Could not find all required header columns ('Lower Limit', 'Upper Limit') in table headers: {e}\")\n            break # Skip this table\n\n        # Process data rows (skip header row)\n        for data_row in rows[1:]:\n             if data_row.get(\"type\") != \"tr\" or \"children\" not in data_row:\n                 print(\"Warning: Skipping non-row element in table children.\")\n                 continue # Skip non-row elements\n\n             cells = data_row[\"children\"]\n             # Ensure row has enough cells for limit columns\n             if len(cells) > max(lower_limit_col_idx, upper_limit_col_idx):\n                 lower_limit_str = extract_text_from_content(cells[lower_limit_col_idx])\n                 upper_limit_str = extract_text_from_content(cells[upper_limit_col_idx])\n\n                 # Store limits in order\n                 spec_limits_list.append({\n                      'Lower Limit': lower_limit_str, # Keep as string initially\n                      'Upper Limit': upper_limit_str  # Keep as string initially\n                 })\n                 # print(f\"Extracted from spec table row: {lower_limit_str} - {upper_limit_str}\") # Debugging line\n             else:\n                 print(\"Warning: Skipping table row with insufficient cells for limit columns.\")\n\n\n        # Assuming only one relevant table, stop after finding the first one\n        break\n\nif not table_found:\n     print(\"Warning: No table found in Product Specification page content.\")\nelif not spec_limits_list:\n     print(\"Warning: No parameter limits extracted from the table.\")\n\n\n# --- Collate Data for Submission Table ---\n\nsubmission_data_rows = []\n\n# Define the list of parameter names expected in the Batch entity\nparameter_names_to_process = [\"Parameter 1\", \"Parameter 2\", \"Parameter 3\"]\n\n# Iterate through the defined parameter names and extracted limits by index\nif len(parameter_names_to_process) != len(spec_limits_list):\n    print(f\"Warning: Number of parameters ({len(parameter_names_to_process)}) does not match number of limit rows extracted ({len(spec_limits_list)}). Submitting only matching parameters.\")\n    # Adjust the loop range to the minimum of the two lists\n    loop_range = min(len(parameter_names_to_process), len(spec_limits_list))\nelse:\n    loop_range = len(parameter_names_to_process)\n\nfor i in range(loop_range):\n    parameter_name = parameter_names_to_process[i]\n\n    # Get the parameter value from the Batch entity\n    batch_field_info = batch_fields.get(parameter_name)\n    batch_value = batch_field_info.get(\"value\") if batch_field_info else None\n\n    # Get the limits from the extracted spec data list using index\n    limits = spec_limits_list[i] if i < len(spec_limits_list) else None\n\n    # Convert values to numbers before adding to submission data\n    converted_batch_value = safe_float_conversion(batch_value)\n    converted_lower_limit = safe_float_conversion(limits.get('Lower Limit')) if limits else None\n    converted_upper_limit = safe_float_conversion(limits.get('Upper Limit')) if limits else None\n\n\n    if converted_batch_value is not None and limits: # Only process if Batch value is found AND limits were extracted for this index\n        # Add data for this parameter to the submission list\n        submission_data_rows.append({\n           'Parameter': parameter_name,\n           'Lower Limit': converted_lower_limit,\n           'Upper Limit': converted_upper_limit,\n           'Value': converted_batch_value # Use the converted value\n        })\n        print(f\"Found parameter '{parameter_name}': Batch Value='{converted_batch_value}', Spec Limits='{converted_lower_limit}' - '{converted_upper_limit}'\")\n    elif converted_batch_value is not None and not limits:\n         print(f\"Warning: Parameter '{parameter_name}' found in Batch with value '{converted_batch_value}', but corresponding limits were not found in the Product Specification table (index {i}).\")\n    else:\n        print(f\"Warning: Parameter '{parameter_name}' not found or has no value in Batch entity, skipping.\")\n\n\n# --- Submit Data to Submission Table ---\n\n# Create pandas DataFrame from the collected data\nif not submission_data_rows:\n    print(\"\\nNo complete parameter data (Batch value + Spec limits) found to submit.\")\n    # Optional: Clear the submission table if no data is found\n    # try:\n    #     seal.submit_to_instance_submission_field(\"Submission\", field_values_df=pd.DataFrame({\n    #     # Assuming these columns exist in your Submission table template/config\n    #         'Parameter': [], 'Lower Limit': [], 'Upper Limit': [], 'Value': []\n    #     }))\n    #     print(\"Cleared existing data in 'Submission' field.\")\n    # except Exception as e:\n    #      print(f\"Warning: Failed to clear 'Submission' field: {e}\")\n    exit()\n\ndf = pd.DataFrame(submission_data_rows)\n\n# The submission field name in the containing CoA template\nsubmission_field_name = \"Submission\"\n\nprint(f\"\\nSubmitting {len(submission_data_rows)} rows to '{submission_field_name}' field...\")\n\n# Check if the CoA instance is editable before submitting\nif coa_instance.get(\"status\") != \"EDITABLE\":\n    print(f\"CoA instance '{coa_instance.get('title', coa_instance['id'])}' is not editable. Making it editable.\")\n    try:\n        seal.make_entity_editable(coa_instance[\"id\"])\n        # Re-fetch the entity to get the editable version data if needed, though submit_to_instance_submission_field might handle this\n        # coa_instance = seal.get_containing_entity()\n    except Exception as e:\n        print(f\"Error: Failed to make CoA instance editable: {e}\")\n        raise e # Re-raise to stop script if cannot edit\n\ntry:\n    # Submit the DataFrame to the specified submission field\n    # The template for the submission table instances is configured on the field itself\n    seal.submit_to_instance_submission_field(\n        submission_field_name,\n        field_values_df=df\n    )\n    print(f\"Successfully submitted data to '{submission_field_name}' field.\")\n\nexcept Exception as e:\n    print(f\"Error: Failed to submit data to '{submission_field_name}' field: {e}\")\n    raise e # Re-raise the exception to indicate script failure in Seal"
    }
  }
}
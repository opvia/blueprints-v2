{
  "schemaVersion": "2.0.0",
  "id": "ffa0e86f-fc7a-4b8f-abd8-b23f74ce5f2a",
  "title": "Create Label",
  "status": "EDITABLE",
  "version": null,
  "previousVersion": null,
  "metadata": {
    "index": "0",
    "createdAt": "1970-01-01T00:00:00.000Z",
    "lastUpdatedAt": "1970-01-01T00:00:00.000Z",
    "createdByRoleId": "44444444-4444-4444-4444-444444444444",
    "lastUpdatedByRoleId": "44444444-4444-4444-4444-444444444444",
    "editors": [],
    "typeIndex": "0"
  },
  "sourceInfo": {
    "template": {
      "id": "14a859f2-c3d5-4066-8cc9-d27fa585c162",
      "version": "1"
    }
  },
  "fields": {
    "Documentation": {
      "id": "fa772c7f-d7a5-47f9-8841-ebc1202b7902",
      "type": "REFERENCE",
      "value": [
        {
          "id": "9747df80-022e-497b-b294-5a9fd17207ee",
          "version": "1"
        }
      ],
      "config": {
        "allowMultiple": false
      },
      "dataType": "ENTITY"
    },
    "Label Configuration Template": {
      "id": "522a2f0f-79ef-4a80-960a-ede43de35045",
      "type": "REFERENCE",
      "value": [
        {
          "id": "4ded1db0-1946-42d8-bf53-0de6c6dd384e",
          "version": "1"
        }
      ],
      "config": {
        "allowMultiple": false
      },
      "dataType": "ENTITY"
    }
  },
  "kind": "INSTANCE",
  "type": {
    "ref": {
      "id": "cb760dbe-2a51-4a9d-8f5b-3a429cc814bc"
    }
  },
  "content": {
    "type": "SCRIPT_CODE",
    "value": {
      "triggers": [
        {
          "id": "7b948530-cd9b-4307-937e-36348ed82c35",
          "name": "On Packing Slip Published",
          "entityRefs": [
            {
              "id": "fefd1d79-bd4f-4032-8fde-feaa43f646ac"
            }
          ],
          "systemEvent": "onMoveOutOfEditable",
          "appliesToEntityKinds": "INSTANCE"
        }
      ],
      "scriptCode": "import io\nimport os\nimport time\nfrom datetime import datetime\nfrom zoneinfo import ZoneInfo\n\nfrom reportlab.graphics.barcode import code39, code128, qr  # type: ignore\nfrom reportlab.lib import colors  # type: ignore\nfrom reportlab.lib.colors import black, blue, gray, red, white  # type: ignore\nfrom reportlab.lib.units import cm, inch, mm  # type: ignore\nfrom reportlab.pdfbase.pdfmetrics import stringWidth  # type: ignore\nfrom reportlab.pdfgen import canvas  # type: ignore\nfrom reportlab.platypus import Table, TableStyle  # type: ignore\n\n\nUNIT_OBJECTS = {\"cm\": cm, \"mm\": mm, \"inch\": inch}\n\nCOLOR_MAP = {\n    \"Black\": black,\n    \"Gray\": gray,\n    \"Blue\": blue,\n    \"Red\": red,\n    \"White\": white,\n    \"None\": None,\n}\n\nDEFAULT_FONT_SIZE = 10\nDEFAULT_FONT_NAME = \"Helvetica\"\n\n# Entity properties support (copied from compute.ts)\nENTITY_PROPERTIES = [\n    \"CREATED_AT\",\n    \"CREATED_BY\",\n    \"EDITORS\",\n    \"ID\",\n    \"INDEX\",\n    \"LAST_EDITED_AT\",\n    \"LAST_EDITED_BY\",\n    \"TEMPLATE_INDEX\",\n    \"TITLE\",\n    \"TYPE_INDEX\",\n    \"SUBMITTED_FROM\",\n    \"CREATED_FROM\",\n]\n\n\ndef is_entity_property(property_name):\n    \"\"\"Check if a property name is an entity property (case-insensitive)\"\"\"\n    return property_name.upper() in ENTITY_PROPERTIES\n\n\ndef get_field_or_property_value(entity, column_name):\n    \"\"\"Get value from entity field or property (case-insensitive for properties)\"\"\"\n    if is_entity_property(column_name):\n        property_name = column_name.upper()\n        if property_name == \"TITLE\":\n            return entity.get(\"title\", \"\")\n        elif property_name == \"ID\":\n            return entity.get(\"id\", \"\")\n        elif property_name == \"CREATED_AT\":\n            return entity.get(\"createdAt\", \"\")\n        elif property_name == \"CREATED_BY\":\n            return entity.get(\"createdBy\", \"\")\n        elif property_name == \"EDITORS\":\n            return entity.get(\"editors\", \"\")\n        elif property_name == \"INDEX\":\n            return entity.get(\"index\", \"\")\n        elif property_name == \"LAST_EDITED_AT\":\n            return entity.get(\"lastEditedAt\", \"\")\n        elif property_name == \"LAST_EDITED_BY\":\n            return entity.get(\"lastEditedBy\", \"\")\n        elif property_name == \"TEMPLATE_INDEX\":\n            return entity.get(\"templateIndex\", \"\")\n        elif property_name == \"TYPE_INDEX\":\n            return entity.get(\"typeIndex\", \"\")\n        elif property_name == \"SUBMITTED_FROM\":\n            return entity.get(\"submittedFrom\", \"\")\n        elif property_name == \"CREATED_FROM\":\n            return entity.get(\"createdFrom\", \"\")\n        else:\n            # hard to maintain let's fallback to lowercase\n            return entity.get(column_name.lower(), \"\")\n    else:\n        # Handle field values using existing function\n        fields = entity.get(\"fields\", {})\n        return extract_field_value(fields, column_name, \"\")\n\n\ndef extract_field_value(field_dict, field_name, default_value):\n    \"\"\"Extract field value handling SELECT arrays and whitespace\"\"\"\n    field_value = field_dict.get(field_name, {}).get(\"value\", default_value)\n\n    if isinstance(field_value, list) and field_value:\n        result = field_value[0]\n    elif isinstance(field_value, list):\n        result = default_value\n    else:\n        result = field_value if field_value is not None else default_value\n\n    return result\n\n\ndef collect_all_entity_references(entity_data, config):\n    \"\"\"Collect all entity references from REFERENCE and INSTANCE_SUBMISSION fields to batch fetch them\"\"\"\n    entity_refs_to_fetch = set()\n\n    # Look through all entity data for entity references\n    for field_name, field_value in entity_data.items():\n        if isinstance(field_value, list):\n            for item in field_value:\n                if isinstance(item, dict) and \"id\" in item:\n                    entity_refs_to_fetch.add(item[\"id\"])\n\n    return list(entity_refs_to_fetch)\n\n\ndef collect_entity_references_from_entity(entity):\n    \"\"\"Collect entity references from an entity's REFERENCE and INSTANCE_SUBMISSION fields\"\"\"\n    entity_refs_to_fetch = set()\n    fields = entity.get(\"fields\", {})\n\n    for field_name, field_info in fields.items():\n        field_type = field_info.get(\"type\", \"\")\n        field_value = field_info.get(\"value\", \"\")\n\n        # Look for REFERENCE and INSTANCE_SUBMISSION fields\n        if field_type in [\"REFERENCE\", \"INSTANCE_SUBMISSION\"] and isinstance(\n            field_value, list\n        ):\n            for ref in field_value:\n                if isinstance(ref, dict) and \"id\" in ref:\n                    entity_refs_to_fetch.add(ref[\"id\"])\n\n    return list(entity_refs_to_fetch)\n\n\ndef batch_fetch_entities(entity_ids, entity_cache):\n    \"\"\"Fetch multiple entities and add to cache\"\"\"\n    if not entity_ids:\n        return entity_cache\n\n    for entity_id in entity_ids:\n        if entity_id not in entity_cache:\n            try:\n                entity = seal.get_entity(entity_id=entity_id)\n                entity_cache[entity_id] = entity\n                entity_title = entity.get(\"title\", \"Untitled\")\n                print(f\"Fetched entity: {entity_title}\")\n            except Exception as e:\n                print(f\"Failed to fetch entity {entity_id}: {e}\")\n                entity_cache[entity_id] = None\n\n    return entity_cache\n\n\ndef find_config_for_template(config_template_id, target_template_id):\n    \"\"\"Find configuration instance(s) that support the target template ID\"\"\"\n    if not config_template_id:\n        return {\"matches\": [], \"error\": \"No configuration template ID provided\"}\n\n    # Search for instances created from the configuration template\n    search_query = {\"filters\": {\"kind\": [\"INSTANCE\"], \"template\": [config_template_id]}}\n\n    try:\n        config_instances = seal.search_entities(search_query)\n        matching_configs = []\n\n        for instance in config_instances:\n            try:\n                instance_entity = seal.get_entity(entity_id=instance[\"id\"])\n                instance_fields = instance_entity.get(\"fields\", {})\n\n                # Check the Templates reference field\n                templates_refs = instance_fields.get(\"Templates\", {}).get(\"value\", [])\n\n                if templates_refs and isinstance(templates_refs, list):\n                    supported_template_ids = [\n                        ref.get(\"id\", \"\") for ref in templates_refs\n                    ]\n\n                    if target_template_id in supported_template_ids:\n                        config_title = instance_entity.get(\n                            \"title\", f\"Untitled Config ({instance_entity['id']})\"\n                        )\n                        matching_configs.append(\n                            {\"id\": instance_entity[\"id\"], \"title\": config_title}\n                        )\n\n            except Exception as e:\n                print(f\"Failed to process config instance {instance['id']}: {str(e)}\")\n                continue\n\n        if len(matching_configs) == 0:\n            return {\n                \"matches\": [],\n                \"error\": f\"No configuration found for template '{target_template_id}'\",\n            }\n        elif len(matching_configs) == 1:\n            print(\n                f\"Found configuration '{matching_configs[0]['title']}' for template '{target_template_id}'\"\n            )\n            return {\"matches\": matching_configs, \"error\": None}\n        else:\n            # Multiple matches - this is an error condition\n            config_titles = [config[\"title\"] for config in matching_configs]\n            config_list = \", \".join(config_titles)\n            print(\n                f\"WARNING: Found {len(matching_configs)} configurations for template \"\n                f\"'{target_template_id}': {config_list}\"\n            )\n            error_message = (\n                f\"Multiple configurations found for template '{target_template_id}': \"\n                f\"{config_list}. Please delete unused configurations to avoid ambiguity.\"\n            )\n            return {\n                \"matches\": matching_configs,\n                \"error\": error_message,\n            }\n\n    except Exception as e:\n        return {\n            \"matches\": [],\n            \"error\": f\"Failed to search for configuration instances: {str(e)}\",\n        }\n\n\ndef main():\n    \"\"\"Main entry point with tri-mode detection\"\"\"\n    try:\n        config = load_script_configuration()\n\n        try:\n            trigger_info = seal.get_trigger_info()\n            print(\"Running in TRIGGER MODE\")\n            run_trigger_mode(config, trigger_info.triggered_by_entity_id)\n        except Exception as e:\n            if \"not called as a trigger\" in str(e):\n                # Determine if Preview or Manual mode based on containing entity\n                mode_info = config.get(\"_mode_info\", {})\n                if mode_info.get(\"mode\") == \"preview\":\n                    print(\"Running in PREVIEW MODE\")\n                    run_preview_mode(config)\n                elif mode_info.get(\"mode\") == \"manual\":\n                    print(\"Running in MANUAL MODE\")\n                    run_manual_mode(config, mode_info.get(\"containing_entity_id\"))\n                else:\n                    raise Exception(\"Could not determine script mode\")\n            else:\n                raise e\n\n    except Exception as e:\n        print(f\"Script execution failed: {str(e)}\")\n        raise\n\n\ndef load_script_configuration():\n    \"\"\"Load configuration from referenced configuration entity\"\"\"\n    script_entity_id = seal.entity_id\n\n    script_entity = seal.get_entity(entity_id=script_entity_id)\n    script_fields = script_entity.get(\"fields\", {})\n\n    # Determine which configuration entity to use\n    config_entity = None\n    config_field_name = None\n\n    try:\n        # Try to get trigger info to determine the triggering entity template\n        trigger_info = seal.get_trigger_info()\n        triggering_entity_id = trigger_info.triggered_by_entity_id\n        triggering_entity = seal.get_entity(entity_id=triggering_entity_id)\n        triggering_template_ref = triggering_entity.get(\"sourceInfo\", {}).get(\n            \"template\", {}\n        )\n        triggering_template_id = triggering_template_ref.get(\"id\", \"\")\n\n        if not triggering_template_id:\n            raise Exception(\"Triggering entity has no template ID\")\n\n        # Get the Label Configuration Template reference from script entity\n        script_entity_id = seal.entity_id\n        script_entity = seal.get_entity(entity_id=script_entity_id)\n        script_fields = script_entity.get(\"fields\", {})\n\n        config_template_refs = script_fields.get(\n            \"Label Configuration Template\", {}\n        ).get(\"value\", [])\n\n        if (\n            not config_template_refs\n            or not isinstance(config_template_refs, list)\n            or len(config_template_refs) == 0\n        ):\n            raise Exception(\n                \"No Label Configuration Template found in script. Please add a \"\n                \"'Label Configuration Template' reference field to the script entity.\"\n            )\n\n        config_template_id = config_template_refs[0].get(\"id\", \"\")\n\n        if not config_template_id:\n            raise Exception(\"Label Configuration Template reference is invalid\")\n\n        # Search for configuration instance that supports this template\n        config_result = find_config_for_template(\n            config_template_id, triggering_template_id\n        )\n\n        if config_result[\"error\"]:\n            error_details = config_result[\"error\"]\n            raise Exception(\n                f\"Configuration lookup failed for template '{triggering_template_id}': \"\n                f\"{error_details}\\n\"\n                f\"Please ensure you have exactly one configuration instance from the \"\n                f\"Label Configuration Template with '{triggering_template_id}' in the \"\n                f\"'Templates' field.\"\n            )\n\n        config_entity_id = config_result[\"matches\"][0][\"id\"]\n        config_field_name = f\"Trigger Mode (template {triggering_template_id})\"\n\n        config_entity = seal.get_entity(entity_id=config_entity_id)\n\n    except Exception as e:\n        try:\n            containing_entity = seal.get_containing_entity()\n            containing_fields = containing_entity.get(\"fields\", {})\n\n            # Check if containing entity has \"Label Elements\" field to determine mode\n            if \"Label Elements\" in containing_fields:\n                # Preview mode: containing entity is a configuration entity\n                config_entity = containing_entity\n                config_field_name = \"Preview Mode\"\n                mode = \"preview\"\n            else:\n                # Manual mode: containing entity is a regular entity that wants a label\n                config_entity = None  # Will be determined from Label Configuration Template instances\n                config_field_name = \"Manual Mode\"\n                mode = \"manual\"\n                containing_entity_id = containing_entity[\"id\"]\n\n            if mode == \"manual\":\n                # Manual mode: find configuration using containing entity's template\n                containing_template_ref = containing_entity.get(\"sourceInfo\", {}).get(\n                    \"template\", {}\n                )\n                containing_template_id = containing_template_ref.get(\"id\", \"\")\n\n                if not containing_template_id:\n                    raise Exception(\"Manual mode: Containing entity has no template ID\")\n\n                # Get Label Configuration Template from script entity to find matching config\n                script_entity_id = seal.entity_id\n                script_entity = seal.get_entity(entity_id=script_entity_id)\n                script_fields = script_entity.get(\"fields\", {})\n\n                config_template_refs = script_fields.get(\n                    \"Label Configuration Template\", {}\n                ).get(\"value\", [])\n\n                if (\n                    not config_template_refs\n                    or not isinstance(config_template_refs, list)\n                    or len(config_template_refs) == 0\n                ):\n                    raise Exception(\n                        \"Manual mode failed: No 'Label Configuration Template' reference field found in script entity. \"\n                        \"Please add a 'Label Configuration Template' reference field to the script.\"\n                    )\n\n                config_template_id = config_template_refs[0].get(\"id\", \"\")\n\n                if not config_template_id:\n                    raise Exception(\n                        \"Manual mode failed: Label Configuration Template reference is invalid\"\n                    )\n\n                # Find configuration instance that supports containing entity's template\n                config_result = find_config_for_template(\n                    config_template_id, containing_template_id\n                )\n\n                if config_result[\"error\"]:\n                    error_details = config_result[\"error\"]\n                    raise Exception(\n                        f\"Manual mode failed: Configuration lookup failed for template \"\n                        f\"'{containing_template_id}': {error_details}\\n\"\n                        f\"Please ensure you have exactly one configuration instance from the \"\n                        f\"Label Configuration Template with '{containing_template_id}' in the \"\n                        f\"'Templates' field.\"\n                    )\n\n                config_entity_id = config_result[\"matches\"][0][\"id\"]\n\n                config_entity = seal.get_entity(entity_id=config_entity_id)\n                config_field_name = f\"Manual Mode (template {containing_template_id})\"\n                print(\n                    f\"Manual mode: Found configuration for template '{containing_template_id}'\"\n                )\n\n            # Validate that the script has a properly configured Label Configuration Template (Preview mode only)\n            if mode == \"preview\":\n                preview_entities_refs = (\n                    config_entity.get(\"fields\", {})\n                    .get(\"Preview Entities\", {})\n                    .get(\"value\", [])\n                )\n\n                if preview_entities_refs:\n                    # Check if script entity has Label Configuration Template field\n                    script_entity_id = seal.entity_id\n                    script_entity = seal.get_entity(entity_id=script_entity_id)\n                    script_fields = script_entity.get(\"fields\", {})\n\n                    config_template_refs = script_fields.get(\n                        \"Label Configuration Template\", {}\n                    ).get(\"value\", [])\n\n                    if (\n                        not config_template_refs\n                        or not isinstance(config_template_refs, list)\n                        or len(config_template_refs) == 0\n                    ):\n                        print(\n                            \"INFO: No 'Label Configuration Template' reference field found in script entity. \"\n                            \"Preview will work, but this script won't trigger in trigger. \"\n                            \"To enable trigger mode, add a 'Label Configuration Template' \"\n                            \"reference field to the script entity.\"\n                        )\n                        config_field_name = \"Preview Mode (no trigger configuration)\"\n                        # Skip further validation since there's no Label Configuration Template\n                        preview_validation_complete = True\n                    else:\n                        config_template_id = config_template_refs[0].get(\"id\", \"\")\n                        preview_validation_complete = False\n\n                    # Check that preview entities' templates are covered in Label Configuration Template\n                    if not preview_validation_complete:\n                        first_preview_entity = seal.get_entity(\n                            entity_id=preview_entities_refs[0][\"id\"]\n                        )\n                        preview_template_ref = first_preview_entity.get(\n                            \"sourceInfo\", {}\n                        ).get(\"template\", {})\n                        preview_template_id = preview_template_ref.get(\"id\", \"\")\n\n                        if preview_template_id:\n                            # Check if Label Configuration Template instances support this template\n                            config_result = find_config_for_template(\n                                config_template_id, preview_template_id\n                            )\n\n                            if config_result[\"error\"]:\n                                error_details = config_result[\"error\"]\n                                print(\n                                    f\"WARNING: Configuration lookup failed for preview entity \"\n                                    f\"template '{preview_template_id}': {error_details}. \"\n                                    f\"This preview will generate successfully, but entities with this \"\n                                    f\"template will NOT trigger the script in trigger mode. To enable \"\n                                    f\"trigger mode, ensure you have exactly one configuration instance \"\n                                    f\"from the Label Configuration Template with '{preview_template_id}' \"\n                                    f\"in the 'Templates' field.\"\n                                )\n                                config_field_name = (\n                                    \"Preview Mode (template not configured for trigger)\"\n                                )\n                            elif (\n                                config_result[\"matches\"][0][\"id\"] != config_entity[\"id\"]\n                            ):\n                                found_config_id = config_result[\"matches\"][0][\"id\"]\n                                found_config_title = config_result[\"matches\"][0][\n                                    \"title\"\n                                ]\n                                raise Exception(\n                                    f\"Script validation failed: Label Configuration Template instances \"\n                                    f\"contain template '{preview_template_id}' but point to config \"\n                                    f\"'{found_config_title}' (ID: {found_config_id}) instead of this \"\n                                    f\"configuration entity '{config_entity['id']}'. Please update the \"\n                                    f\"configuration instance.\"\n                                )\n                            else:\n                                config_field_name = \"Preview Mode (validated Label Configuration Template)\"\n                        else:\n                            print(\n                                \"Preview entities found but first entity has no template - \"\n                                \"skipping script validation\"\n                            )\n                else:\n                    print(\"No preview entities configured - skipping script validation\")\n                    config_field_name = \"Preview Mode\"\n\n        except Exception as preview_error:\n            raise Exception(\n                f\"Cannot determine configuration entity.\\n\"\n                f\"Trigger mode failed: {str(e)}\\n\"\n                f\"Embedded mode failed: {str(preview_error)}\"\n            )\n\n    if not config_entity:\n        raise Exception(\"Could not load configuration entity\")\n\n    print(f\"Using configuration: {config_field_name} (ID: {config_entity['id']})\")\n\n    fields = config_entity.get(\"fields\", {})\n\n    units = extract_field_value(fields, \"Units\", \"cm\")\n\n    label_width = extract_field_value(fields, \"Label Width\", 10.0)\n    label_height = extract_field_value(fields, \"Label Height\", 5.0)\n    print(f\"Label configuration: {label_width} x {label_height} {units}\")\n\n    config = {\n        \"Label Width\": label_width,\n        \"Label Height\": label_height,\n        \"Default Font\": extract_field_value(fields, \"Default Font\", DEFAULT_FONT_NAME),\n        \"Default Font Size\": extract_field_value(\n            fields, \"Default Font Size\", DEFAULT_FONT_SIZE\n        ),\n        \"Units\": units,\n        \"Preview Entities\": fields.get(\"Preview Entities\", {}).get(\"value\", []),\n        \"Show Grid Lines\": False,  # Default to False, will be overridden in preview mode if needed\n    }\n\n    # Load layout elements from Label Elements reference field\n    layout_elements_field = fields.get(\"Label Elements\", {})\n    layout_elements = []\n\n    if layout_elements_field and \"value\" in layout_elements_field:\n        element_refs = layout_elements_field[\"value\"]\n\n        if not element_refs:\n            print(\"Label Elements field is empty - no elements will be rendered\")\n\n        for element_ref in element_refs:\n            try:\n                element_entity = seal.get_entity(entity_id=element_ref[\"id\"])\n                element_fields = element_entity.get(\"fields\", {})\n\n                # Extract element configuration with defaults\n                element = {\n                    \"Element Type\": extract_field_value(\n                        element_fields, \"Element Type\", \"Text\"\n                    ),\n                    \"Text\": extract_field_value(\n                        element_fields, \"Text\", \"\"\n                    ),  # For Text elements\n                    \"Field Or Property Name\": extract_field_value(\n                        element_fields, \"Field Or Property Name\", \"\"\n                    ),  # For all other elements\n                    \"Column Names\": extract_field_value(\n                        element_fields, \"Column Names\", \"\"\n                    ),  # For Table elements - comma-separated text field\n                    \"Prefix Text\": extract_field_value(\n                        element_fields, \"Prefix Text\", \"\"\n                    ),\n                    \"X Position\": extract_field_value(element_fields, \"X Position\", 0),\n                    \"Y Position\": extract_field_value(element_fields, \"Y Position\", 0),\n                    \"Width\": extract_field_value(element_fields, \"Width\", 2.0),\n                    \"Height\": extract_field_value(element_fields, \"Height\", 1.0),\n                    \"Font Name\": extract_field_value(\n                        element_fields, \"Font Name (optional)\", DEFAULT_FONT_NAME\n                    ),\n                    \"Font Size\": extract_field_value(\n                        element_fields, \"Font Size (optional)\", None\n                    ),  # None = use default\n                    \"Alignment\": extract_field_value(\n                        element_fields, \"Alignment\", \"Top-Left\"\n                    ),  # Universal alignment\n                    \"Rotation (°)\": extract_field_value(\n                        element_fields, \"Rotation (°)\", 0\n                    ),  # Rotation in degrees\n                    \"Line Width\": extract_field_value(element_fields, \"Line Width\", 1),\n                    \"Stroke Color\": extract_field_value(\n                        element_fields, \"Stroke Color\", \"Black\"\n                    ),\n                }\n                layout_elements.append(element)\n\n            except Exception as e:\n                print(f\"Failed to load layout element {element_ref['id']}: {str(e)}\")\n                continue\n\n    config[\"Label Elements\"] = layout_elements\n    config[\"Configuration Entity ID\"] = config_entity[\"id\"]\n\n    # Add mode information for tri-mode detection\n    if \"mode\" in locals():\n        config[\"_mode_info\"] = {\n            \"mode\": mode,\n            \"containing_entity_id\": containing_entity_id if mode == \"manual\" else None,\n        }\n\n        # In preview mode, check for \"Show Gridlines\" field\n        if mode == \"preview\":\n            show_gridlines_field = fields.get(\n                \"Show Gridlines (only shown in preview mode)\", {\"value\": False}\n            )\n            config[\"Show Grid Lines\"] = show_gridlines_field.get(\"value\")\n            if config[\"Show Grid Lines\"]:\n                print(\"Grid lines enabled via 'Show Gridlines' field\")\n\n    print(\n        f\"Loaded {len(layout_elements)} label elements using config '{config_field_name}'\"\n    )\n    return config\n\n\ndef convert_coordinates(x, y, canvas_obj):\n    \"\"\"\n    Convert from top-left coordinate system to ReportLab's bottom-left system\n\n    User coordinates: (0,0) = top-left, Y increases downward\n    ReportLab: (0,0) = bottom-left, Y increases upward\n    \"\"\"\n    height = canvas_obj._label_height\n    return x, height - y\n\n\ndef calculate_aligned_position(x, y, width, height, alignment):\n    \"\"\"\n    Calculate actual drawing position based on alignment anchor point\n\n    Args:\n        x, y: User-specified coordinates\n        width, height: Element dimensions (in same units as x, y)\n        alignment: \"Top-Left\", \"Center\", \"Top-Right\", \"Bottom-Left\", \"Bottom-Right\" (case-insensitive)\n\n    Returns:\n        (adjusted_x, adjusted_y): Actual position for drawing\n    \"\"\"\n    # Make alignment detection case-insensitive\n    alignment_upper = alignment.upper()\n\n    if alignment_upper == \"CENTER\" or alignment_upper == \"CENTRE\":\n        return x - width / 2, y - height / 2\n    elif alignment_upper == \"TOP-RIGHT\":\n        return x - width, y\n    elif alignment_upper == \"BOTTOM-LEFT\":\n        return x, y - height\n    elif alignment_upper == \"BOTTOM-RIGHT\":\n        return x - width, y - height\n    else:  # \"TOP-LEFT\" or any other value defaults to top-left\n        return x, y\n\n\ndef apply_rotation_to_canvas(canvas_obj, rotation_degrees, anchor_x, anchor_y):\n    \"\"\"\n    Apply rotation around a specific anchor point\n\n    Args:\n        canvas_obj: ReportLab canvas object\n        rotation_degrees: Rotation angle in degrees (clockwise)\n        anchor_x, anchor_y: Point to rotate around (in ReportLab coordinates)\n    \"\"\"\n    if rotation_degrees != 0:\n        # Save current state\n        canvas_obj.saveState()\n\n        # Translate to anchor point, rotate, then translate back\n        canvas_obj.translate(anchor_x, anchor_y)\n        canvas_obj.rotate(rotation_degrees)\n        canvas_obj.translate(-anchor_x, -anchor_y)\n\n        return True  # Indicates rotation was applied\n    return False  # No rotation applied\n\n\ndef render_element_with_rotation(canvas_obj, element, x, y, unit_obj, render_callback):\n    \"\"\"\n    Base render function that handles common rotation setup/teardown for all element types\n\n    Args:\n        canvas_obj: ReportLab canvas object\n        element: Element configuration dict\n        x, y: User coordinates\n        unit_obj: ReportLab unit object (cm, mm, inch)\n        render_callback: Function that performs the actual rendering\n                        Signature: render_callback(canvas_obj, element, x, y, unit_obj, anchor_coords)\n                        where anchor_coords is (anchor_x_rl, anchor_y_rl)\n    \"\"\"\n    rotation = element.get(\"Rotation (°)\", 0)\n    if isinstance(rotation, list) and rotation:\n        rotation = rotation[0]\n    if not isinstance(rotation, (int, float)):\n        rotation = 0\n\n    anchor_x = x * unit_obj\n    anchor_y = y * unit_obj\n    anchor_x_rl, anchor_y_rl = convert_coordinates(anchor_x, anchor_y, canvas_obj)\n\n    rotation_applied = apply_rotation_to_canvas(\n        canvas_obj, rotation, anchor_x_rl, anchor_y_rl\n    )\n\n    try:\n        render_callback(canvas_obj, element, x, y, unit_obj, (anchor_x_rl, anchor_y_rl))\n\n    finally:\n        if rotation_applied:\n            canvas_obj.restoreState()\n\n\ndef check_page_break(y_position, canvas_obj, min_space=50):\n    \"\"\"\n    Check if we need a page break and create one if necessary\n    Returns the new Y position (reset to top if page break occurred)\n    \"\"\"\n    if y_position < min_space:  # Less than min_space points from bottom\n        canvas_obj.showPage()\n        # After page break, we're back to top-left coordinates\n        return canvas_obj._label_height - 20  # Start 20 points from top\n    return y_position\n\n\ndef draw_grid_lines(canvas_obj, label_width, label_height, units, unit_obj):\n    \"\"\"\n    Draw grid lines to help with element positioning (preview mode only)\n\n    Args:\n        canvas_obj: ReportLab canvas object\n        label_width: Label width in user units\n        label_height: Label height in user units\n        units: Unit type (\"cm\", \"mm\", \"inch\")\n        unit_obj: ReportLab unit object\n    \"\"\"\n    # Grid colors (subtle so they don't interfere with content)\n    major_grid_color = (0.7, 0.7, 0.7)  # Light gray for major lines\n    minor_grid_color = (0.9, 0.9, 0.9)  # Very light gray for minor lines\n\n    # Define grid spacing based on units\n    if units == \"cm\":\n        major_spacing = 1.0  # Every 1 cm\n        minor_spacing = 0.5  # Every 0.5 cm\n    elif units == \"mm\":\n        major_spacing = 10.0  # Every 10 mm\n        minor_spacing = 5.0  # Every 5 mm\n    elif units == \"inch\":\n        major_spacing = 1.0  # Every 1 inch\n        minor_spacing = 0.25  # Every 0.25 inch\n    else:\n        major_spacing = 1.0\n        minor_spacing = 0.5\n\n    # Convert to points\n    width_points = label_width * unit_obj\n    height_points = label_height * unit_obj\n\n    canvas_obj.saveState()\n\n    # Draw minor grid lines first (so they appear behind major lines)\n    canvas_obj.setStrokeColorRGB(*minor_grid_color)\n    canvas_obj.setLineWidth(0.25)\n\n    # Vertical minor lines\n    x = minor_spacing\n    while x < label_width:\n        x_points = x * unit_obj\n        canvas_obj.line(x_points, 0, x_points, height_points)\n        x += minor_spacing\n\n    # Horizontal minor lines\n    y = minor_spacing\n    while y < label_height:\n        y_points = height_points - (y * unit_obj)  # Convert to ReportLab coordinates\n        canvas_obj.line(0, y_points, width_points, y_points)\n        y += minor_spacing\n\n    # Draw major grid lines\n    canvas_obj.setStrokeColorRGB(*major_grid_color)\n    canvas_obj.setLineWidth(0.5)\n\n    # Vertical major lines with labels\n    x = major_spacing\n    while x <= label_width:\n        x_points = x * unit_obj\n        canvas_obj.line(x_points, 0, x_points, height_points)\n\n        # Add coordinate labels at the top\n        canvas_obj.setFont(\"Helvetica\", 6)\n        canvas_obj.setFillColorRGB(*major_grid_color)\n        label_text = f\"{int(x)}\" if x == int(x) else f\"{x:.1f}\"\n        canvas_obj.drawCentredString(x_points, height_points - 10, label_text)\n\n        x += major_spacing\n\n    # Horizontal major lines with labels\n    y = major_spacing\n    while y <= label_height:\n        y_points = height_points - (y * unit_obj)  # Convert to ReportLab coordinates\n        canvas_obj.line(0, y_points, width_points, y_points)\n\n        # Add coordinate labels on the left\n        canvas_obj.setFont(\"Helvetica\", 6)\n        canvas_obj.setFillColorRGB(*major_grid_color)\n        label_text = f\"{int(y)}\" if y == int(y) else f\"{y:.1f}\"\n        canvas_obj.drawString(3, y_points - 2, label_text)\n\n        y += major_spacing\n\n    # Draw border\n    canvas_obj.setStrokeColorRGB(*major_grid_color)\n    canvas_obj.setLineWidth(1.0)\n    canvas_obj.rect(0, 0, width_points, height_points, stroke=1, fill=0)\n\n    # Add unit labels in corners\n    canvas_obj.setFont(\"Helvetica\", 8)\n    canvas_obj.setFillColorRGB(*major_grid_color)\n    canvas_obj.drawString(5, height_points - 15, f\"Preview Mode Grid: {units}\")\n    canvas_obj.drawRightString(\n        width_points - 5, 5, f\"Size: {label_width} x {label_height} {units}\"\n    )\n\n    canvas_obj.restoreState()\n\n\ndef create_label_pdf(config, entity_data):\n    \"\"\"\n    SHARED label generation core used by both modes\n\n    Args:\n        config: Dict of configuration values (width, height, label elements, etc.)\n        entity_data: Dict of entity field values\n\n    Returns:\n        PDF buffer ready for upload\n    \"\"\"\n    print(\"Starting PDF generation...\")\n\n    # Initialize entity cache for Table elements\n    if \"_entity_cache\" not in config:\n        config[\"_entity_cache\"] = {}\n\n        # Pre-populate cache with entities from reference fields\n        source_entity = entity_data.get(\"_source_entity\", {})\n        entity_refs_to_fetch = collect_entity_references_from_entity(source_entity)\n        if entity_refs_to_fetch:\n            config[\"_entity_cache\"] = batch_fetch_entities(\n                entity_refs_to_fetch, config[\"_entity_cache\"]\n            )\n\n    units = config.get(\"Units\", \"cm\")\n    unit_obj = UNIT_OBJECTS[units]\n\n    width = config.get(\"Label Width\", 10.0) * unit_obj\n    height = config.get(\"Label Height\", 5.0) * unit_obj\n\n    pdf_buffer = io.BytesIO()\n    canvas_obj = canvas.Canvas(pdf_buffer, pagesize=(width, height))\n\n    # Store dimensions for coordinate conversion\n    canvas_obj._label_width = width\n    canvas_obj._label_height = height\n\n    # Draw grid lines in preview mode if enabled\n    if config.get(\"Show Grid Lines\", False):\n        draw_grid_lines(\n            canvas_obj,\n            config.get(\"Label Width\", 10.0),\n            config.get(\"Label Height\", 5.0),\n            units,\n            unit_obj,\n        )\n\n    layout_elements = config.get(\"Label Elements\", [])\n    print(f\"Processing {len(layout_elements)} label elements\")\n\n    for i, element in enumerate(layout_elements):\n        try:\n            render_layout_element(canvas_obj, element, entity_data, unit_obj, config)\n        except Exception as e:\n            print(f\"Failed to render layout element {i + 1}: {str(e)}\")\n            continue\n\n    canvas_obj.save()\n    pdf_buffer.seek(0)\n    return pdf_buffer\n\n\ndef render_layout_element(canvas_obj, element, entity_data, unit_obj, config):\n    \"\"\"Render a single layout element on the canvas\"\"\"\n    element_type = element.get(\"Element Type\", \"\").strip()\n    \n    # Handle Table element type\n    if element_type == \"Table\":\n        x_pos = element.get(\"X Position\", 0)\n        y_pos = element.get(\"Y Position\", 0)\n        alignment = element.get(\"Alignment\", \"Top-Left\")\n        if isinstance(alignment, list) and alignment:\n            alignment = alignment[0].strip()\n        elif isinstance(alignment, str):\n            alignment = alignment.strip()\n        else:\n            alignment = \"Top-Left\"\n        render_table_element(\n            canvas_obj, element, entity_data, x_pos, y_pos, unit_obj, config, alignment\n        )\n        return\n\n    if element_type == \"Text\":\n        value_or_field_name = element.get(\"Text\", \"\").strip()\n    else:\n        value_or_field_name = element.get(\"Field Or Property Name\", \"\").strip()\n\n    x_pos = element.get(\"X Position\", 0)\n    y_pos = element.get(\"Y Position\", 0)\n\n    alignment = element.get(\"Alignment\", \"Top-Left\")\n    if isinstance(alignment, list) and alignment:\n        alignment = alignment[0].strip()\n    elif isinstance(alignment, str):\n        alignment = alignment.strip()\n    else:\n        alignment = \"Top-Left\"\n    x = x_pos * unit_obj\n    y = y_pos * unit_obj\n\n    # Convert from top-left to bottom-left coordinates\n    x_final, y_final = convert_coordinates(x, y, canvas_obj)\n\n    if element_type == \"Page Break\":\n        canvas_obj.showPage()\n        return\n\n    prefix_text = element.get(\"Prefix Text\", \"\")\n\n    if element_type == \"Text\":\n        base_value = value_or_field_name\n    elif element_type == \"Field\":\n        # Handle both entity properties and field values\n        if is_entity_property(value_or_field_name):\n            # Get from entity properties (need the full entity)\n            source_entity = entity_data.get(\"_source_entity\", {})\n            base_value = get_field_or_property_value(source_entity, value_or_field_name)\n        else:\n            # Get from entity fields using utility (supports case-insensitive properties)\n            source_entity = entity_data.get(\"_source_entity\", {})\n            base_value = get_field_or_property_value(source_entity, value_or_field_name)\n\n        if not base_value and value_or_field_name:\n            print(\n                f\"Field or property '{value_or_field_name}' not found in entity data, skipping element\"\n            )\n            return\n    elif element_type in [\"Barcode Code128\", \"QR Code\", \"Barcode Code39\"]:\n        # Get from entity properties (need the full entity)\n        source_entity = entity_data.get(\"_source_entity\", {})\n        base_value = get_field_or_property_value(source_entity, value_or_field_name)\n\n        if not base_value and value_or_field_name:\n            print(\n                f\"Field or property '{value_or_field_name}' not found in entity data, skipping element\"\n            )\n            return\n        \n        # For barcodes, use base value without prefix (barcodes need clean data)\n        final_value = base_value\n    elif element_type == \"Image\":    \n        source_entity = entity_data.get(\"_source_entity\", {})\n        image_refs = get_field_or_property_value(source_entity, value_or_field_name)\n\n        if not image_refs:\n            print(\n                f\"Image reference field or property '{value_or_field_name}' not found, skipping element\"\n            )\n            return\n        final_value = image_refs\n    elif element_type == \"Border\":\n        base_value = \"\"\n        final_value = \"\"\n    else:\n        print(f\"Unknown element type: {element_type}\")\n        return\n\n    if element_type in [\"Text\", \"Field\"]:\n        final_value = f\"{prefix_text}{base_value}\" if prefix_text else base_value\n    # Render the appropriate element\n    if element_type in [\"Text\", \"Field\"]:\n        render_text_element(\n            canvas_obj, element, final_value, x_pos, y_pos, unit_obj, config, alignment\n        )\n    elif element_type in [\"Barcode Code128\", \"QR Code\", \"Barcode Code39\"]:\n        render_barcode_element(\n            canvas_obj, element, final_value, x_pos, y_pos, unit_obj, alignment\n        )\n    elif element_type == \"Image\":\n        render_image_element(\n            canvas_obj, element, final_value, x_pos, y_pos, unit_obj, alignment\n        )\n    elif element_type == \"Border\":\n        render_rectangle_element(canvas_obj, element, x_pos, y_pos, unit_obj, alignment)\n\n\ndef render_text_element(\n    canvas_obj, element, field_value, x, y, unit_obj, config, alignment\n):\n    \"\"\"Render text element with universal alignment and rotation support\"\"\"\n\n    def render_text_callback(canvas_obj, element, x, y, unit_obj, anchor_coords):\n        \"\"\"Specific text rendering logic\"\"\"\n        font_name = element.get(\"Font Name\", None)\n        if font_name is None:\n            font_name = config.get(\"Default Font\", DEFAULT_FONT_NAME)\n        font_size = element.get(\"Font Size\", None)\n        if font_size is None:\n            font_size = config.get(\"Default Font Size\", DEFAULT_FONT_SIZE)\n        stroke_color = COLOR_MAP.get(element.get(\"Stroke Color\", \"Black\"), black)\n\n        alignment_upper = alignment.upper()\n        if \"RIGHT\" in alignment_upper:\n            text_alignment = \"Right\"\n        elif \"CENTER\" in alignment_upper or \"CENTRE\" in alignment_upper:\n            text_alignment = \"Center\"\n        else:\n            text_alignment = \"Left\"\n\n        text_str = str(field_value)\n\n        # Split text by newlines for multiline support\n        text_lines = text_str.split(\"\\n\")\n\n        # Calculate dimensions for all lines\n        max_text_width = 0\n        for line in text_lines:\n            line_width = stringWidth(line, font_name, font_size)\n            max_text_width = max(max_text_width, line_width)\n\n        # Calculate total text height (font size + line spacing for each line)\n        line_spacing = font_size * 0.2  # 20% of font size for line spacing\n        total_text_height = (\n            len(text_lines) * font_size + (len(text_lines) - 1) * line_spacing\n        )\n\n        # Use the same alignment approach as images - calculate aligned position and stick with it\n        aligned_x, aligned_y = calculate_aligned_position(\n            x, y, max_text_width / unit_obj, total_text_height / unit_obj, alignment\n        )\n\n        # Convert aligned position to ReportLab coordinates\n        aligned_x_final = aligned_x * unit_obj\n        aligned_y_final = aligned_y * unit_obj\n        aligned_x_rl, aligned_y_rl = convert_coordinates(\n            aligned_x_final, aligned_y_final, canvas_obj\n        )\n\n        canvas_obj.setFont(font_name, font_size)\n        if stroke_color:\n            canvas_obj.setFillColor(stroke_color)\n\n        # For center alignment, we need the original coordinates (where user wants the center)\n        if text_alignment == \"Center\":\n            original_x_rl = x * unit_obj  # Original x coordinate in ReportLab units\n\n        # Draw each line separately\n        for line_index, line in enumerate(text_lines):\n            # Calculate Y position for this line (ReportLab draws from baseline)\n            line_y = (\n                aligned_y_rl\n                - font_size * 0.8\n                - (line_index * (font_size + line_spacing))\n            )\n\n            if text_alignment == \"Center\":\n                # For center: use the original coordinates as the center point (avoid double-centering)\n                canvas_obj.drawCentredString(original_x_rl, line_y, line)\n            elif text_alignment == \"Right\":\n                # For right: use the right edge of the aligned text area\n                right_x = aligned_x_rl + max_text_width\n                canvas_obj.drawRightString(right_x, line_y, line)\n            else:\n                # For left: use the left edge of the aligned text area\n                canvas_obj.drawString(aligned_x_rl, line_y, line)\n\n    render_element_with_rotation(\n        canvas_obj, element, x, y, unit_obj, render_text_callback\n    )\n\n\ndef render_barcode_element(canvas_obj, element, field_value, x, y, unit_obj, alignment):\n    \"\"\"Render barcode element with universal alignment and rotation support\"\"\"\n\n    def render_barcode_callback(canvas_obj, element, x, y, unit_obj, anchor_coords):\n        \"\"\"Specific barcode rendering logic\"\"\"\n        element_type = element.get(\"Element Type\")\n        desired_width = element.get(\"Width\", 2.0) * unit_obj\n        height = element.get(\"Height\", 1.0) * unit_obj\n\n        try:\n            canvas_obj.saveState()\n\n            canvas_obj.setStrokeColor(black)\n            canvas_obj.setFillColor(black)\n\n            if element_type == \"Barcode Code128\":\n                # Calculate appropriate barWidth for desired total width\n                # For Code128, typical character width is about 11 units, so estimate total units needed\n                estimated_units = (\n                    len(str(field_value)) * 11 + 35\n                )  # 35 for start/stop/checksum\n                target_bar_width = desired_width / estimated_units\n\n                # Ensure minimum bar width for readability (at least 0.5 points)\n                min_bar_width = 0.5\n                bar_width = max(target_bar_width, min_bar_width)\n\n                barcode = code128.Code128(\n                    value=str(field_value),\n                    barHeight=height,\n                    barWidth=bar_width,\n                    humanReadable=True,\n                    quiet=0,  # Disable quiet zones for precise alignment\n                    lquiet=0,\n                    rquiet=0,\n                )\n\n                actual_barcode_width = barcode.width\n\n                draw_x, draw_y = calculate_aligned_position(\n                    x, y, actual_barcode_width / unit_obj, height / unit_obj, alignment\n                )\n                draw_x_final = draw_x * unit_obj\n                draw_y_final = draw_y * unit_obj\n                draw_x_rl, draw_y_rl = convert_coordinates(\n                    draw_x_final, draw_y_final, canvas_obj\n                )\n\n                # Adjust Y coordinate: ReportLab draws barcodes from bottom-left, we want top-left positioning\n                actual_barcode_y = draw_y_rl - height\n\n                barcode.drawOn(canvas_obj, draw_x_rl, actual_barcode_y)\n\n            elif element_type == \"Barcode Code39\":\n                # Calculate appropriate barWidth for desired total width\n                # For Code39, each character is about 13 units wide\n                estimated_units = len(str(field_value)) * 13 + 25  # 25 for start/stop\n                target_bar_width = desired_width / estimated_units\n\n                # Ensure minimum bar width for readability\n                min_bar_width = 0.5\n                bar_width = max(target_bar_width, min_bar_width)\n\n                barcode = code39.Standard39(\n                    value=str(field_value),\n                    barHeight=height,\n                    barWidth=bar_width,\n                    humanReadable=True,\n                    quiet=0,  # Disable quiet zones for precise alignment\n                    lquiet=0,\n                    rquiet=0,\n                )\n\n                actual_barcode_width = barcode.width\n\n                draw_x, draw_y = calculate_aligned_position(\n                    x, y, actual_barcode_width / unit_obj, height / unit_obj, alignment\n                )\n                draw_x_final = draw_x * unit_obj\n                draw_y_final = draw_y * unit_obj\n                draw_x_rl, draw_y_rl = convert_coordinates(\n                    draw_x_final, draw_y_final, canvas_obj\n                )\n\n                # Adjust Y coordinate: ReportLab draws barcodes from bottom-left, we want top-left positioning\n                actual_barcode_y = draw_y_rl - height\n\n                barcode.drawOn(canvas_obj, draw_x_rl, actual_barcode_y)\n\n            elif element_type == \"QR Code\":\n                # QR codes use the width and height directly\n                draw_x, draw_y = calculate_aligned_position(\n                    x, y, desired_width / unit_obj, height / unit_obj, alignment\n                )\n                draw_x_final = draw_x * unit_obj\n                draw_y_final = draw_y * unit_obj\n                draw_x_rl, draw_y_rl = convert_coordinates(\n                    draw_x_final, draw_y_final, canvas_obj\n                )\n\n                qr_code = qr.QrCodeWidget(str(field_value))\n                qr_code.barWidth = desired_width\n                qr_code.barHeight = height\n\n                from reportlab.graphics import renderPDF  # type: ignore\n                from reportlab.graphics.shapes import Drawing  # type: ignore\n\n                drawing = Drawing(desired_width, height)\n                drawing.add(qr_code)\n\n                # Adjust Y coordinate: ReportLab draws from bottom-left, we want top-left positioning\n                qr_y = draw_y_rl - height\n                renderPDF.draw(drawing, canvas_obj, draw_x_rl, qr_y)\n\n            canvas_obj.restoreState()\n\n        except Exception as e:\n            print(f\"Failed to render barcode {element_type}: {str(e)}\")\n            canvas_obj.restoreState()\n\n            fallback_x, fallback_y = calculate_aligned_position(\n                x, y, 100 / unit_obj, 8 / unit_obj, alignment\n            )\n            fallback_x_final = fallback_x * unit_obj\n            fallback_y_final = fallback_y * unit_obj\n            fallback_x_rl, fallback_y_rl = convert_coordinates(\n                fallback_x_final, fallback_y_final, canvas_obj\n            )\n\n            canvas_obj.setFont(\"Helvetica\", 8)\n            fallback_text_y = fallback_y_rl - 8 * 0.8\n            canvas_obj.drawString(\n                fallback_x_rl, fallback_text_y, f\"Barcode: {field_value}\"\n            )\n\n    render_element_with_rotation(\n        canvas_obj, element, x, y, unit_obj, render_barcode_callback\n    )\n\n\ndef render_rectangle_element(canvas_obj, element, x, y, unit_obj, alignment):\n    \"\"\"Render border element with universal alignment and rotation support\"\"\"\n\n    def render_rectangle_callback(canvas_obj, element, x, y, unit_obj, anchor_coords):\n        \"\"\"Specific rectangle/border rendering logic\"\"\"\n        width = element.get(\"Width\", 2.0) * unit_obj\n        height = element.get(\"Height\", 1.0) * unit_obj\n        line_width = element.get(\"Line Width\", 1)\n        stroke_color = COLOR_MAP.get(element.get(\"Stroke Color\", \"Black\"))\n\n        aligned_x, aligned_y = calculate_aligned_position(\n            x, y, width / unit_obj, height / unit_obj, alignment\n        )\n\n        x_final = aligned_x * unit_obj\n        y_final = aligned_y * unit_obj\n        x_rl, y_rl = convert_coordinates(x_final, y_final, canvas_obj)\n\n        canvas_obj.setLineWidth(line_width)\n        if stroke_color:\n            canvas_obj.setStrokeColor(stroke_color)\n\n        # Adjust Y coordinate: ReportLab draws rectangles from bottom-left, we want top-left positioning\n        rect_y = y_rl - height\n\n        stroke_flag = 1 if stroke_color else 0\n        canvas_obj.rect(x_rl, rect_y, width, height, stroke=stroke_flag, fill=0)\n\n    render_element_with_rotation(\n        canvas_obj, element, x, y, unit_obj, render_rectangle_callback\n    )\n\n\ndef render_table_element(\n    canvas_obj, element, entity_data, x, y, unit_obj, config, alignment\n):\n    \"\"\"Render table using ReportLab's Table class\"\"\"\n\n    def render_table_callback(canvas_obj, element, x, y, unit_obj, anchor_coords):\n        \"\"\"Specific table rendering logic\"\"\"\n        # Get table configuration\n        field_name = element.get(\"Field Or Property Name\", \"\").strip()\n        column_names_text = element.get(\"Column Names\", \"\").strip()\n\n        print(f\"Column Names: {column_names_text}\")\n\n        # Parse comma-separated column names into a list\n        if column_names_text:\n            column_names = [\n                name.strip() for name in column_names_text.split(\",\") if name.strip()\n            ]\n        else:\n            column_names = []\n\n        if not field_name or not column_names:\n            return\n\n        # Get entity references from the specified field\n        # For table elements, we need the FULL array of references, not just the first one\n        source_entity = entity_data.get(\"_source_entity\", {})\n\n        if is_entity_property(field_name):\n            entity_refs = get_field_or_property_value(source_entity, field_name)\n        else:\n            fields = source_entity.get(\"fields\", {})\n            entity_refs = fields.get(field_name, {}).get(\"value\", [])\n\n        if not entity_refs:\n            print(f\"DEBUG: No entity references found in field '{field_name}'\")\n            return\n\n        entity_cache = config.get(\"_entity_cache\", {})\n\n        entity_ids_to_fetch = []\n        for ref in entity_refs:\n            if isinstance(ref, dict) and \"id\" in ref:\n                entity_id = ref[\"id\"]\n                if entity_id not in entity_cache:\n                    entity_ids_to_fetch.append(entity_id)\n\n        # Batch fetch any missing entities\n        if entity_ids_to_fetch:\n            entity_cache = batch_fetch_entities(entity_ids_to_fetch, entity_cache)\n            config[\"_entity_cache\"] = entity_cache\n\n        # Build table data\n        table_data = []\n\n        # Header row - use column names as headers\n        headers = column_names[:]  # Copy the list\n        table_data.append(headers)\n\n        # Data rows\n        for ref in entity_refs:\n            if isinstance(ref, dict) and \"id\" in ref:\n                entity_id = ref[\"id\"]\n                if entity_id in entity_cache and entity_cache[entity_id]:\n                    entity = entity_cache[entity_id]\n                    row = []\n\n                    for column_name in column_names:\n                        value = get_field_or_property_value(entity, column_name)\n                        row.append(str(value) if value else \"\")\n\n                    table_data.append(row)\n\n        if len(table_data) <= 1:  # Only headers\n            return\n\n        # Get font size for the table - use element font size or fall back to global default\n        table_font_size = element.get(\"Font Size\")\n        if table_font_size is None:\n            table_font_size = config.get(\"Default Font Size\", DEFAULT_FONT_SIZE)\n        if isinstance(table_font_size, list) and table_font_size:\n            table_font_size = table_font_size[0]\n        if not isinstance(table_font_size, (int, float)) or table_font_size <= 0:\n            table_font_size = config.get(\"Default Font Size\", DEFAULT_FONT_SIZE)\n\n        # Get font name for the table - use element font name or fall back to global default\n        table_font_name = element.get(\"Font Name\")\n        if table_font_name is None:\n            table_font_name = config.get(\"Default Font\", DEFAULT_FONT_NAME)\n\n        # Get bold version of the font for headers\n        if table_font_name == \"Helvetica\":\n            table_font_bold = \"Helvetica-Bold\"\n        elif table_font_name == \"Times-Roman\":\n            table_font_bold = \"Times-Bold\"\n        elif table_font_name == \"Courier\":\n            table_font_bold = \"Courier-Bold\"\n        else:\n            # For unknown fonts, try adding -Bold or fall back to the same font\n            table_font_bold = (\n                f\"{table_font_name}-Bold\"\n                if not table_font_name.endswith(\"-Bold\")\n                else table_font_name\n            )\n\n        # Calculate dimensions first - needed for column width and row height calculation\n        cell_padding = table_font_size * 0.3\n        border_width = table_font_size * 0.05  # 5% of font size for border thickness\n        row_height = (\n            table_font_size * 1.8\n        )  # 180% of font size for row height (extra space for vertical centering)\n\n        min_col_widths = []\n        for col_index in range(len(column_names)):\n            max_width = 0\n            for row in table_data:\n                if col_index < len(row):\n                    cell_text = str(row[col_index])\n                    # Use header font for header row, data font for data rows\n                    font_name = (\n                        table_font_bold if row == table_data[0] else table_font_name\n                    )\n                    text_width = stringWidth(cell_text, font_name, table_font_size)\n                    max_width = max(max_width, text_width)\n\n            # Add padding (both sides) plus some extra margin for large fonts\n            padding_multiplier = 0.5  # More padding for large fonts\n            min_width = (\n                max_width + (cell_padding * 2) + (table_font_size * padding_multiplier)\n            )\n            min_col_widths.append(min_width)\n\n        # Create explicit row heights for proper vertical alignment\n        row_heights = [row_height] * len(table_data)  # Same height for all rows\n\n        # Create ReportLab Table with calculated column widths AND explicit row heights\n        table = Table(table_data, colWidths=min_col_widths, rowHeights=row_heights)\n\n        # Build complete style commands list including row heights\n        style_commands = [\n            # Header row styling - background and font first\n            (\"BACKGROUND\", (0, 0), (-1, 0), colors.gray),\n            (\"TEXTCOLOR\", (0, 0), (-1, 0), colors.white),\n            (\"FONTNAME\", (0, 0), (-1, 0), table_font_bold),\n            (\"FONTSIZE\", (0, 0), (-1, 0), table_font_size),\n            # Data rows styling - background and font\n            (\"BACKGROUND\", (0, 1), (-1, -1), colors.white),\n            (\"TEXTCOLOR\", (0, 1), (-1, -1), colors.black),\n            (\"FONTNAME\", (0, 1), (-1, -1), table_font_name),\n            (\"FONTSIZE\", (0, 1), (-1, -1), table_font_size),\n            # Row backgrounds for readability - alternating white and light gray\n            (\"ROWBACKGROUNDS\", (0, 1), (-1, -1), [colors.white, (0.9, 0.9, 0.9)]),\n            # Grid and borders - thickness relative to font size\n            (\"GRID\", (0, 0), (-1, -1), border_width, colors.black),\n            # Alignment commands LAST - so they take precedence\n            (\"VALIGN\", (0, 0), (-1, -1), \"MIDDLE\"),  # Vertical center\n            (\"ALIGN\", (0, 0), (-1, 0), \"CENTER\"),  # Header row center\n            (\"ALIGN\", (0, 1), (-1, -1), \"CENTER\"),  # Data rows center\n        ]\n\n        # Note: Row heights are now set in Table constructor, not via MINHEIGHT style commands\n        # This ensures proper vertical alignment with VALIGN\n\n        table_style = TableStyle(style_commands)\n        table.setStyle(table_style)\n\n        # CRITICAL: Wrap the table to calculate natural dimensions (ReportLab requirement)\n        canvas_width = canvas_obj._label_width\n        canvas_height = canvas_obj._label_height\n\n        try:\n            actual_table_width, actual_table_height = table.wrap(\n                canvas_width, canvas_height\n            )\n        except (ValueError, TypeError):\n            # Fallback: calculate dimensions from our explicit column widths and row count\n            actual_table_width = sum(min_col_widths)\n            actual_table_height = len(table_data) * row_height\n\n        # Calculate position with alignment using ACTUAL table dimensions\n        aligned_x, aligned_y = calculate_aligned_position(\n            x,\n            y,\n            actual_table_width / unit_obj,\n            actual_table_height / unit_obj,\n            alignment,\n        )\n\n        final_x = aligned_x * unit_obj\n        final_y = aligned_y * unit_obj\n\n        final_x_rl, final_y_rl = convert_coordinates(final_x, final_y, canvas_obj)\n\n        # Draw table (ReportLab tables draw from bottom-left)\n        table_y = final_y_rl - actual_table_height\n\n        table.drawOn(canvas_obj, final_x_rl, table_y)\n\n    # Use existing rotation framework\n    # Note: render_table_callback accesses entity_data and config from closure\n    render_element_with_rotation(\n        canvas_obj, element, x, y, unit_obj, render_table_callback\n    )\n\n\ndef render_image_element(canvas_obj, element, image_refs, x, y, unit_obj, alignment):\n    \"\"\"Render image element with universal alignment and rotation support\"\"\"\n\n    def render_image_callback(canvas_obj, element, x, y, unit_obj, anchor_coords):\n        \"\"\"Specific image rendering logic\"\"\"\n        width = element.get(\"Width\", 2.0) * unit_obj\n        height = element.get(\"Height\", 1.0) * unit_obj\n\n        aligned_x, aligned_y = calculate_aligned_position(\n            x, y, width / unit_obj, height / unit_obj, alignment\n        )\n\n        x_final = aligned_x * unit_obj\n        y_final = aligned_y * unit_obj\n        x_rl, y_rl = convert_coordinates(x_final, y_final, canvas_obj)\n\n        try:\n            if isinstance(image_refs, list) and image_refs:\n                image_ref = image_refs[0]\n            elif isinstance(image_refs, dict):\n                image_ref = image_refs\n            else:\n                print(f\"Invalid image reference format: {image_refs}\")\n                return\n\n            image_entity_id = image_ref.get(\"id\", \"\")\n            if not image_entity_id:\n                print(\"No image entity ID found in reference\")\n                return\n\n            if image_ref.get(\"version\"):\n                temp_path = seal.download_file(\n                    file_entity_id=image_entity_id, version=image_ref[\"version\"]\n                )\n            else:\n                temp_path = seal.download_file(file_entity_id=image_entity_id)\n\n            try:\n                # Adjust Y coordinate: ReportLab draws images from bottom-left, we want top-left positioning\n                image_y = y_rl - height\n\n                canvas_obj.drawImage(\n                    temp_path, x_rl, image_y, width=width, height=height, mask=\"auto\"\n                )\n\n            finally:\n                try:\n                    os.unlink(temp_path)\n                except Exception as cleanup_error:\n                    print(f\"Failed to clean up downloaded file: {cleanup_error}\")\n\n        except Exception as e:\n            print(f\"Failed to render image: {str(e)}\")\n            canvas_obj.setFont(\"Helvetica\", 8)\n            fallback_y = y_rl - 8 * 0.8\n            canvas_obj.drawString(x_rl, fallback_y, \"[Image Error]\")\n\n    render_element_with_rotation(\n        canvas_obj, element, x, y, unit_obj, render_image_callback\n    )\n\n\ndef extract_entity_fields(entity):\n    \"\"\"Extract all field values from an entity for label generation\"\"\"\n    entity_data = {}\n    fields = entity.get(\"fields\", {})\n\n    for field_name, field_info in fields.items():\n        field_value = field_info.get(\"value\", \"\")\n        field_data_type = field_info.get(\"dataType\", \"\")\n\n        if isinstance(field_value, list):\n            if (\n                field_value\n                and isinstance(field_value[0], dict)\n                and \"id\" in field_value[0]\n            ):\n                if field_data_type in [\"ENTITY\", \"INSTANCE_SUBMISSION\", \"SCRIPT\"]:\n                    entity_data[field_name] = field_value\n                else:\n                    entity_data[field_name] = \", \".join(\n                        [ref.get(\"id\", \"\") for ref in field_value]\n                    )\n            elif field_value:\n                entity_data[field_name] = \", \".join([str(item) for item in field_value])\n            else:\n                entity_data[field_name] = \"\"\n        elif isinstance(field_value, dict):\n            entity_data[field_name] = str(field_value.get(\"value\", field_value))\n        else:\n            entity_data[field_name] = (\n                str(field_value) if field_value is not None else \"\"\n            )\n\n    # Store source entity for property access\n    entity_data[\"_source_entity\"] = entity\n\n    return entity_data\n\n\ndef run_preview_mode(config):\n    \"\"\"Generate Labels for testing\"\"\"\n    preview_entities_refs = config.get(\"Preview Entities\", [])\n\n    if not preview_entities_refs:\n        print(\"No preview entities configured\")\n        return\n\n    preview_labels = []\n\n    for entity_ref in preview_entities_refs:\n        try:\n            print(f\"Generating preview for entity: {entity_ref['id']}\")\n            entity = seal.get_entity(entity_id=entity_ref[\"id\"])\n            label_file = generate_and_upload_label(entity, config, mode=\"Preview\")\n            preview_labels.append(label_file)\n            print(f\"Preview label created successfully: {label_file['id']}\")\n\n        except Exception as e:\n            print(f\"Failed to generate preview for entity {entity_ref['id']}: {str(e)}\")\n            continue\n\n    update_preview_references(preview_labels, config)\n    print(f\"Generated {len(preview_labels)} Labels\")\n\n\ndef run_trigger_mode(config, source_entity_id):\n    \"\"\"Generate label for triggering entity\"\"\"\n    try:\n        entity = seal.get_entity(entity_id=source_entity_id)\n        entity_data = extract_entity_fields(entity)\n        pdf_buffer = create_label_pdf(config, entity_data)\n        create_or_update_trigger_label(pdf_buffer, entity, config)\n        print(f\"Label generated for entity: {entity.get('title')}\")\n\n    except Exception as e:\n        print(f\"Failed to generate trigger label: {str(e)}\")\n        raise\n\n\ndef run_manual_mode(config, containing_entity_id):\n    \"\"\"Generate label for containing entity and try to update Labels field\"\"\"\n    try:\n        entity = seal.get_entity(entity_id=containing_entity_id)\n        label_file = generate_and_upload_label(entity, config, mode=\"Manual\")\n\n        # Try to update Labels field on the containing entity\n        try:\n            update_manual_labels_preview(containing_entity_id, label_file)\n            print(\n                f\"Manual label generated and added to Labels for entity: {entity.get('title')}\"\n            )\n        except Exception as field_error:\n            print(\n                f\"Manual label generated successfully, but failed to update Labels field: {str(field_error)}\"\n            )\n            print(f\"Label file created with ID: {label_file['id']}\")\n\n    except Exception as e:\n        print(f\"Failed to generate manual label: {str(e)}\")\n        raise\n\n\ndef generate_and_upload_label(entity, config, mode=\"Preview\"):\n    \"\"\"Shared logic to generate PDF and upload label for an entity\"\"\"\n    entity_data = extract_entity_fields(entity)\n    pdf_buffer = create_label_pdf(config, entity_data)\n    return upload_pdf_as_label(pdf_buffer, entity, config, mode=mode)\n\n\ndef upload_pdf_as_preview(pdf_buffer, source_entity, config):\n    \"\"\"Upload PDF as preview label file entity\"\"\"\n    return upload_pdf_as_label(pdf_buffer, source_entity, config, mode=\"Preview\")\n\n\ndef upload_pdf_as_label(pdf_buffer, source_entity, config, mode=\"Preview\"):\n    \"\"\"Upload PDF as label file entity with specified mode prefix\"\"\"\n    timestamp = str(int(time.time()))\n\n    title_field_value = get_field_or_property_value(source_entity, \"title\")\n\n    if isinstance(title_field_value, list):\n        entity_title = str(title_field_value[0]) if title_field_value else mode\n    elif isinstance(title_field_value, dict):\n        entity_title = str(title_field_value.get(\"value\", mode))\n    elif title_field_value:\n        entity_title = str(title_field_value)\n    else:\n        entity_title = source_entity.get(\"title\", mode)\n\n    filename = f\"{mode}_{entity_title}_{timestamp}.pdf\"\n\n    temp_filename = f\"temp_{mode.lower()}_{timestamp}.pdf\"\n    with open(temp_filename, \"wb\") as f:\n        f.write(pdf_buffer.read())\n\n    try:\n        file_entity = seal.upload_file(\n            file_path=temp_filename, file_name=filename, type_title=\"Label\"\n        )\n\n        return file_entity\n\n    finally:\n        if os.path.exists(temp_filename):\n            os.remove(temp_filename)\n\n\ndef update_manual_labels_preview(entity_id, label_file):\n    \"\"\"Update the Labels field on an entity with the generated label\"\"\"\n    try:\n        # Get current entity to check if it's editable\n        entity = seal.get_entity(entity_id=entity_id)\n\n        # Make entity editable if it's not already\n        if entity[\"status\"] != \"EDITABLE\":\n            seal.make_entity_editable(entity_id)\n\n        # Create reference to the label file\n        label_ref = {\"id\": label_file[\"id\"], \"version\": None}\n\n        # Get current Labels field value\n        current_entity = seal.get_entity(entity_id=entity_id)\n        current_labels = (\n            current_entity.get(\"fields\", {}).get(\"Labels\", {}).get(\"value\", [])\n        )\n\n        # Add new label to the list (or create new list if field doesn't exist)\n        if isinstance(current_labels, list):\n            updated_labels = current_labels + [label_ref]\n        else:\n            updated_labels = [label_ref]\n\n        # Update the field\n        seal.update_field_value_in_entity(\n            entity_id=entity_id,\n            field_name=\"Labels\",\n            field_value=updated_labels,\n        )\n\n        print(f\"Successfully updated Labels field with {len(updated_labels)} labels\")\n\n    except Exception as e:\n        raise Exception(f\"Failed to update Labels field: {str(e)}\")\n\n\ndef create_or_update_trigger_label(pdf_buffer, source_entity, config):\n    \"\"\"Create or update trigger label (adapted from fixedGenerationScript.py)\"\"\"\n    source_entity_id = source_entity[\"id\"]\n\n    title_field_value = get_field_or_property_value(source_entity, \"title\")\n\n    if isinstance(title_field_value, list):\n        label_title = str(title_field_value[0]) if title_field_value else \"Label\"\n    elif isinstance(title_field_value, dict):\n        label_title = str(title_field_value.get(\"value\", \"Label\"))\n    elif title_field_value:\n        label_title = str(title_field_value)\n    else:\n        label_title = source_entity.get(\"title\", \"Label\")\n\n    timestamp = str(int(time.time()))\n    temp_filename = f\"label_{source_entity_id}_{timestamp}.pdf\"\n    with open(temp_filename, \"wb\") as f:\n        f.write(pdf_buffer.read())\n\n    try:\n        search_query = {\n            \"filters\": {\n                \"fieldValue\": [\n                    {\n                        \"name\": \"Label Source\",\n                        \"operator\": \"=\",\n                        \"value\": f\"ref({source_entity_id})\",\n                    }\n                ]\n            }\n        }\n\n        existing_labels = seal.search_entities(search_query)\n\n        # Use the first matching label by Label Source\n        existing_label_id = existing_labels[0][\"id\"] if existing_labels else None\n\n        if existing_label_id:\n            print(f\"Updating existing label: {existing_label_id}\")\n            update_existing_label(existing_label_id, temp_filename, label_title, config)\n        else:\n            print(f\"Creating new label for entity: {source_entity_id}\")\n            create_new_label(temp_filename, label_title, source_entity_id, config)\n\n    finally:\n        if os.path.exists(temp_filename):\n            os.remove(temp_filename)\n\n\ndef update_existing_label(label_id, temp_filename, label_title, config):\n    \"\"\"Update existing label with new content\"\"\"\n    existing_label = seal.get_entity(entity_id=label_id)\n    if existing_label[\"status\"] != \"EDITABLE\":\n        seal.make_entity_editable(label_id)\n\n    timestamp = str(int(time.time()))\n    unique_filename = f\"{label_title}_label_{timestamp}.pdf\"\n\n    temp_file_entity = seal.upload_file(\n        file_path=temp_filename, file_name=unique_filename, type_title=\"Label\"\n    )\n\n    new_file_id = temp_file_entity[\"content\"][\"value\"][\"fileId\"]\n    new_content = {\"type\": \"FILE\", \"value\": {\"fileId\": new_file_id}}\n\n    seal._request(\n        url=f\"entities/{label_id}/content\",\n        method=\"PATCH\",\n        json={\"content\": new_content},\n    )\n\n    current_title = existing_label.get(\"title\")\n    if current_title != label_title:\n        seal.update_entity_title(label_id, label_title)\n\n    seal.archive_entity(temp_file_entity[\"id\"], True)\n\n    print(f\"Label updated successfully: {label_id}\")\n\n\ndef create_new_label(temp_filename, label_title, source_entity_id, config):\n    \"\"\"Create new label file entity\"\"\"\n    # Upload the PDF file\n    file_entity = seal.upload_file(\n        file_path=temp_filename, file_name=f\"{label_title}.pdf\", type_title=\"Label\"\n    )\n\n    # Update title\n    seal.update_entity_title(file_entity[\"id\"], label_title)\n\n    # Set reference fields\n    label_entity_id = file_entity[\"id\"]\n\n    # Label Source reference\n    seal.update_field_value_in_entity(\n        entity_id=label_entity_id,\n        field_name=\"Label Source\",\n        field_value=[{\"id\": source_entity_id, \"version\": None}],\n    )\n\n    print(f\"New label created successfully: {label_entity_id}\")\n\n\ndef update_preview_references(preview_labels, config):\n    \"\"\"Update the Labels reference field in configuration entity\"\"\"\n    if not preview_labels:\n        return\n\n    config_entity_id = config.get(\"Configuration Entity ID\")\n    if not config_entity_id:\n        print(\"No configuration entity ID found, cannot update Labels\")\n        return\n\n    preview_refs = [{\"id\": label[\"id\"], \"version\": None} for label in preview_labels]\n\n    try:\n        seal.update_field_value_in_entity(\n            entity_id=config_entity_id,\n            field_name=\"Labels\",\n            field_value=preview_refs,\n        )\n        print(\n            f\"Updated Labels on configuration entity with {len(preview_refs)} references\"\n        )\n    except Exception as e:\n        print(f\"Failed to update Labels field: {str(e)}\")\n\n\ndef create_label(seal_instance):\n    global seal\n\n    seal = seal_instance\n\n    return main()\n\nmain()"
    }
  }
}
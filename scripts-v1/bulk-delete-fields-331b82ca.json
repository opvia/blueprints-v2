{
  "schemaVersion": "2.0.0",
  "id": "331b82ca-b0b0-4c21-ab5c-58cfaa670835",
  "title": "Bulk Delete Fields",
  "status": "EDITABLE",
  "version": null,
  "previousVersion": null,
  "metadata": {
    "index": "0",
    "createdAt": "1970-01-01T00:00:00.000Z",
    "lastUpdatedAt": "1970-01-01T00:00:00.000Z",
    "createdByRoleId": "44444444-4444-4444-4444-444444444444",
    "lastUpdatedByRoleId": "44444444-4444-4444-4444-444444444444",
    "editors": [],
    "typeIndex": "0"
  },
  "sourceInfo": {},
  "fields": {},
  "kind": "INSTANCE",
  "type": {
    "ref": {
      "id": "6130dcfd-5fed-4a6c-90da-4ac07852f91f"
    }
  },
  "content": {
    "type": "SCRIPT_CODE",
    "value": {
      "scriptCode": "\"\"\"\nBulk Entity Field Operations\n\nThis module contains three functions for bulk operations on entity fields:\n- bulk_add_fields: Add new fields to multiple entities\n- bulk_update_fields: Update existing field values in multiple entities  \n- bulk_delete_fields: Remove fields from multiple entities\n\nEach function reads configuration from the containing entity and applies\nthe operations to all entities selected via Reference Entities and/or Search Entities fields.\n\nUses asyncio for parallel processing to improve performance when dealing with many entities.\n\"\"\"\n\nimport asyncio\nfrom typing import List, Dict, Any, Optional\n\n\n# Maximum concurrent requests / batch size for parallel operations\nMAX_CONCURRENT_REQUESTS = 50\n\n\ndef get_target_entities():\n    \"\"\"\n    Get all unique target entities from both Reference Entities and Search Entities fields.\n    Returns a deduplicated list of entity IDs.\n    \"\"\"\n    target_entity_ids = set()\n    \n    containing_entity = seal.get_containing_entity()\n    \n    # Get entities from Reference Entities field\n    ref_entities = containing_entity.get(\"fields\", {}).get(\"Reference Entities\", {}).get(\"value\", [])\n    if ref_entities:\n        # Extract IDs from reference objects [{id: \"...\", version: \"...\"}, ...]\n        ref_ids = [ref[\"id\"] for ref in ref_entities if isinstance(ref, dict) and \"id\" in ref]\n        target_entity_ids.update(ref_ids)\n        print(f\"  Found {len(ref_ids)} reference entities\")\n    \n    # Get entities from Search Entities field\n    search_config = containing_entity.get(\"fields\", {}).get(\"Search Entities\", {}).get(\"value\", {})\n    # Check if search config has filters configured (empty filters means unconfigured)\n    filters = search_config.get(\"filters\", {}) if isinstance(search_config, dict) else {}\n    has_configured_search = bool(filters)\n    \n    if has_configured_search:\n        print(\"  Executing search query...\")\n        search_results = seal.search_entities(search_config)\n        # search_results is a list of entities\n        search_entity_ids = [e[\"id\"] for e in search_results if isinstance(e, dict) and \"id\" in e]\n        target_entity_ids.update(search_entity_ids)\n        print(f\"  Found {len(search_entity_ids)} entities from search\")\n    else:\n        print(\"  Search Entities field has no filters configured, skipping search\")\n    \n    if not target_entity_ids:\n        print(\"  WARNING: No target entities found from either Reference or Search fields\")\n    \n    return list(target_entity_ids)\n\n\ndef parse_field_names(field_value: Optional[str]) -> List[str]:\n    \"\"\"Parse comma-separated field names from a string field.\"\"\"\n    if not field_value:\n        return []\n    return [name.strip() for name in field_value.split(\",\") if name.strip()]\n\n\ndef get_field_config(containing_entity: Dict[str, Any], field_name: str) -> Optional[Dict[str, Any]]:\n    \"\"\"Get the full configuration for a field from the containing entity.\"\"\"\n    fields = containing_entity.get(\"fields\", {})\n    if field_name in fields:\n        field = fields[field_name]\n        field_config = field.get(\"config\", {})\n        \n        # Extract field configuration\n        config = {\n            \"type\": field.get(\"type\"),\n            \"value\": field.get(\"value\"),\n        }\n        \n        # Extract config-specific properties based on field type\n        if field.get(\"type\") == \"SELECT\":\n            config[\"selectOptions\"] = field_config.get(\"selectOptions\")\n            config[\"allowMultiple\"] = field_config.get(\"allowMultiple\")\n        elif field.get(\"type\") == \"REFERENCE\" or field.get(\"type\") == \"USER\":\n            config[\"allowMultiple\"] = field_config.get(\"allowMultiple\")\n        elif field.get(\"type\") == \"STRING\":\n            config[\"multiLine\"] = field_config.get(\"multiLine\")\n        elif field.get(\"type\") == \"FORMULA\":\n            config[\"formulaExpression\"] = field_config.get(\"formulaExpression\")\n        \n        # Remove None values\n        return {k: v for k, v in config.items() if v is not None}\n    return None\n\n\n# Async wrapper functions for seal operations\nasync def async_get_entity(entity_id: str) -> Optional[Dict[str, Any]]:\n    \"\"\"Async wrapper for seal.get_entity\"\"\"\n    loop = asyncio.get_event_loop()\n    return await loop.run_in_executor(None, seal.get_entity, entity_id)\n\n\nasync def async_update_entity_editable(entity_id: str, editable: bool) -> bool:\n    \"\"\"Async wrapper for seal.make_entity_editable\"\"\"\n    loop = asyncio.get_event_loop()\n    try:\n        # Note: make_entity_editable doesn't take a boolean parameter, it just makes the entity editable\n        if editable:\n            await loop.run_in_executor(None, seal.make_entity_editable, entity_id)\n            return True\n        # If we need to make it not editable, that would be a different operation\n        return False\n    except Exception as e:\n        print(f\"        ERROR making entity {entity_id} editable: {str(e)}\")\n        return False\n\n\nasync def async_add_field(entity_id: str, field_name: str, field_config: Dict[str, Any]) -> bool:\n    \"\"\"Async wrapper for seal.add_field_to_entity\"\"\"\n    loop = asyncio.get_event_loop()\n    try:\n        kwargs = {\n            \"entity_id\": entity_id,\n            \"field_name\": field_name,\n            \"field_type\": field_config[\"type\"]\n        }\n        \n        # Add optional parameters\n        if \"value\" in field_config and field_config[\"value\"] is not None:\n            kwargs[\"field_value\"] = field_config[\"value\"]\n        if \"allowMultiple\" in field_config:\n            kwargs[\"allow_multiple\"] = field_config[\"allowMultiple\"]\n        if \"selectOptions\" in field_config:\n            kwargs[\"select_options\"] = field_config[\"selectOptions\"]\n        if \"multiLine\" in field_config:\n            kwargs[\"multi_line\"] = field_config[\"multiLine\"]\n        if \"formulaExpression\" in field_config:\n            kwargs[\"formula_expression\"] = field_config[\"formulaExpression\"]\n        \n        await loop.run_in_executor(None, lambda: seal.add_field_to_entity(**kwargs))\n        return True\n    except Exception:\n        return False\n\n\nasync def async_update_field(entity_id: str, field_name: str, field_value: Any) -> bool:\n    \"\"\"Async wrapper for seal.update_field_value_in_entity\"\"\"\n    loop = asyncio.get_event_loop()\n    try:\n        await loop.run_in_executor(None, seal.update_field_value_in_entity, entity_id, field_name, field_value)\n        return True\n    except Exception:\n        return False\n\n\nasync def async_delete_field(entity_id: str, field_name: str) -> str:\n    \"\"\"\n    Async wrapper for seal.delete_field_in_entity\n    Returns: 'success', 'not_found', or 'error'\n    \"\"\"\n    loop = asyncio.get_event_loop()\n    try:\n        # First check if the field exists\n        entity = await async_get_entity(entity_id)\n        if entity and field_name not in entity.get(\"fields\", {}):\n            return \"not_found\"\n        \n        # Field exists, try to delete it\n        await loop.run_in_executor(None, seal.delete_field_in_entity, entity_id, field_name)\n        return \"success\"\n    except Exception as e:\n        print(f\"    ERROR deleting field '{field_name}' from entity {entity_id}: {str(e)}\")\n        return \"error\"\n\n\nasync def process_entity_batch(entities: List[str], operation_func, operation_name: str, field_names: List[str], \n                              field_configs: Optional[Dict[str, Dict[str, Any]]] = None) -> Dict[str, Any]:\n    \"\"\"Process a batch of entities concurrently\"\"\"\n    results = {\"success\": [], \"failed\": []}\n    \n    # Create a semaphore to limit concurrent operations\n    semaphore = asyncio.Semaphore(MAX_CONCURRENT_REQUESTS)\n    \n    async def process_single_entity(entity_id: str) -> None:\n        async with semaphore:\n            try:\n                # First, make entity editable if it's not already\n                entity = await async_get_entity(entity_id)\n                if entity and entity.get(\"status\") != \"EDITABLE\":\n                    print(f\"    Making entity {entity_id} editable (current status: {entity.get('status')})\")\n                    success = await async_update_entity_editable(entity_id, True)\n                    if not success:\n                        print(f\"    WARNING: Failed to make entity {entity_id} editable\")\n                \n                # Perform the operation for each field\n                entity_success = True\n                failed_fields = []\n                skipped_fields = []\n                \n                for field_name in field_names:\n                    if operation_name == \"add\":\n                        if field_configs and field_name in field_configs:\n                            success = await operation_func(entity_id, field_name, field_configs[field_name])\n                        else:\n                            success = False\n                        if not success:\n                            entity_success = False\n                            failed_fields.append(field_name)\n                    elif operation_name == \"update\":\n                        if field_configs and field_name in field_configs:\n                            field_value = field_configs[field_name].get(\"value\")\n                            success = await operation_func(entity_id, field_name, field_value)\n                        else:\n                            success = False\n                        if not success:\n                            entity_success = False\n                            failed_fields.append(field_name)\n                    else:  # delete\n                        result = await operation_func(entity_id, field_name)\n                        if result == \"error\":\n                            entity_success = False\n                            failed_fields.append(field_name)\n                        elif result == \"not_found\":\n                            skipped_fields.append(field_name)\n                        # \"success\" means field was deleted successfully\n                \n                # For delete operations, only consider it a failure if there were actual errors\n                if operation_name == \"delete\":\n                    entity_success = len(failed_fields) == 0\n                \n                if entity_success:\n                    results[\"success\"].append(entity_id)\n                else:\n                    results[\"failed\"].append({\n                        \"entity_id\": entity_id,\n                        \"failed_fields\": failed_fields\n                    })\n                    \n            except Exception as e:\n                results[\"failed\"].append({\n                    \"entity_id\": entity_id,\n                    \"error\": str(e)\n                })\n    \n    # Process all entities in the batch concurrently\n    tasks = [process_single_entity(entity_id) for entity_id in entities]\n    await asyncio.gather(*tasks, return_exceptions=True)\n    \n    return results\n\n\nasync def process_entities_in_batches(entity_ids: List[str], operation_func, operation_name: str, \n                                    field_names: List[str], field_configs: Optional[Dict[str, Dict[str, Any]]] = None) -> None:\n    \"\"\"Process all entities in batches with progress tracking\"\"\"\n    total_entities = len(entity_ids)\n    total_success = 0\n    total_failed = 0\n    \n    print(f\"\\nProcessing {total_entities} entities (concurrent requests per batch: {MAX_CONCURRENT_REQUESTS})...\")\n    \n    # Process in batches\n    for i in range(0, total_entities, MAX_CONCURRENT_REQUESTS):\n        batch = entity_ids[i:i + MAX_CONCURRENT_REQUESTS]\n        batch_num = (i // MAX_CONCURRENT_REQUESTS) + 1\n        total_batches = (total_entities + MAX_CONCURRENT_REQUESTS - 1) // MAX_CONCURRENT_REQUESTS\n        \n        print(f\"  Batch {batch_num}/{total_batches}: Processing {len(batch)} entities...\")\n        \n        results = await process_entity_batch(batch, operation_func, operation_name, field_names, field_configs)\n        \n        batch_success = len(results[\"success\"])\n        batch_failed = len(results[\"failed\"])\n        total_success += batch_success\n        total_failed += batch_failed\n        \n        if results[\"failed\"]:\n            print(f\"    Failed entities in this batch: {batch_failed}\")\n            for failure in results[\"failed\"][:5]:  # Show first 5 failures\n                if \"error\" in failure:\n                    print(f\"      Entity {failure['entity_id']}: {failure['error']}\")\n                else:\n                    print(f\"      Entity {failure['entity_id']}: Failed fields: {', '.join(failure['failed_fields'])}\")\n            if len(results[\"failed\"]) > 5:\n                print(f\"      ... and {len(results['failed']) - 5} more\")\n    \n    print(f\"\\nOperation Summary:\")\n    print(f\"  Total entities processed: {total_entities}\")\n    print(f\"  Successful: {total_success}\")\n    print(f\"  Failed: {total_failed}\")\n\n\ndef bulk_add_fields():\n    \"\"\"Add new fields to all selected entities\"\"\"\n    print(\"=== Starting Bulk Add Fields Operation ===\")\n    \n    # Get containing entity to read configuration\n    containing_entity = seal.get_containing_entity()\n    \n    # Get field names to add\n    field_names_str = containing_entity.get(\"fields\", {}).get(\"Field Names To Add\", {}).get(\"value\", \"\")\n    field_names = parse_field_names(field_names_str)\n    \n    if not field_names:\n        print(\"ERROR: No field names specified in 'Field Names To Add'\")\n        return\n    \n    print(f\"Fields to add: {field_names}\")\n    \n    # Get field configurations from containing entity\n    field_configs = {}\n    for field_name in field_names:\n        config = get_field_config(containing_entity, field_name)\n        if config:\n            field_configs[field_name] = config\n        else:\n            print(f\"WARNING: Field '{field_name}' not found in containing entity\")\n    \n    if not field_configs:\n        print(\"ERROR: No valid field configurations found\")\n        return\n    \n    # Get target entities\n    print(\"\\nCollecting target entities...\")\n    target_entity_ids = get_target_entities()\n    \n    if not target_entity_ids:\n        print(\"No target entities found\")\n        return\n    \n    print(f\"Found {len(target_entity_ids)} unique target entities\")\n    \n    # Process entities\n    asyncio.run(process_entities_in_batches(\n        target_entity_ids, \n        async_add_field, \n        \"add\", \n        field_names, \n        field_configs\n    ))\n    \n    print(\"\\n=== Bulk Add Fields Operation Complete ===\")\n\n\ndef bulk_update_fields():\n    \"\"\"Update existing field values in all selected entities\"\"\"\n    print(\"=== Starting Bulk Update Fields Operation ===\")\n    \n    # Get containing entity to read configuration\n    containing_entity = seal.get_containing_entity()\n    \n    # Get field names to update\n    field_names_str = containing_entity.get(\"fields\", {}).get(\"Field Names To Update\", {}).get(\"value\", \"\")\n    field_names = parse_field_names(field_names_str)\n    \n    if not field_names:\n        print(\"ERROR: No field names specified in 'Field Names To Update'\")\n        return\n    \n    print(f\"Fields to update: {field_names}\")\n    \n    # Get field values from containing entity\n    field_configs = {}\n    for field_name in field_names:\n        config = get_field_config(containing_entity, field_name)\n        if config and \"value\" in config:\n            field_configs[field_name] = config\n        else:\n            print(f\"WARNING: Field '{field_name}' not found or has no value in containing entity\")\n    \n    if not field_configs:\n        print(\"ERROR: No valid field values found\")\n        return\n    \n    # Get target entities\n    print(\"\\nCollecting target entities...\")\n    target_entity_ids = get_target_entities()\n    \n    if not target_entity_ids:\n        print(\"No target entities found\")\n        return\n    \n    print(f\"Found {len(target_entity_ids)} unique target entities\")\n    \n    # Process entities\n    asyncio.run(process_entities_in_batches(\n        target_entity_ids, \n        async_update_field, \n        \"update\", \n        field_names, \n        field_configs\n    ))\n    \n    print(\"\\n=== Bulk Update Fields Operation Complete ===\")\n\n\ndef bulk_delete_fields():\n    \"\"\"Delete fields from all selected entities\"\"\"\n    print(\"=== Starting Bulk Delete Fields Operation ===\")\n    \n    # Get containing entity to read configuration\n    containing_entity = seal.get_containing_entity()\n    \n    # Get field names to delete\n    field_names_str = containing_entity.get(\"fields\", {}).get(\"Field Names To Delete\", {}).get(\"value\", \"\")\n    field_names = parse_field_names(field_names_str)\n    \n    if not field_names:\n        print(\"ERROR: No field names specified in 'Field Names To Delete'\")\n        return\n    \n    print(f\"Fields to delete: {field_names}\")\n    \n    # Get target entities\n    print(\"\\nCollecting target entities...\")\n    target_entity_ids = get_target_entities()\n    \n    if not target_entity_ids:\n        print(\"No target entities found\")\n        return\n    \n    print(f\"Found {len(target_entity_ids)} unique target entities\")\n    \n    # Process entities\n    asyncio.run(process_entities_in_batches(\n        target_entity_ids, \n        async_delete_field, \n        \"delete\", \n        field_names\n    ))\n    \n    print(\"\\n=== Bulk Delete Fields Operation Complete ===\")\n\nbulk_delete_fields()"
    }
  }
}
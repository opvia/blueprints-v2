{
  "schemaVersion": "2.0.0",
  "id": "7c2f19b9-8f4b-4052-bfc3-d9cd511b35d2",
  "title": "Generate Template From CSV",
  "status": "EDITABLE",
  "version": null,
  "previousVersion": null,
  "metadata": {
    "index": "0",
    "createdAt": "1970-01-01T00:00:00.000Z",
    "lastUpdatedAt": "1970-01-01T00:00:00.000Z",
    "createdByRoleId": "44444444-4444-4444-4444-444444444444",
    "lastUpdatedByRoleId": "44444444-4444-4444-4444-444444444444",
    "editors": [],
    "typeIndex": "0"
  },
  "sourceInfo": {},
  "fields": {},
  "kind": "INSTANCE",
  "type": {
    "ref": {
      "id": "6130dcfd-5fed-4a6c-90da-4ac07852f91f"
    }
  },
  "content": {
    "type": "SCRIPT_CODE",
    "value": {
      "scriptCode": "import pandas as pd\nimport re\nfrom datetime import datetime\nfrom typing import Dict, Any, List, Optional\nimport numpy as np\n\n\ndef detect_field_type(series: pd.Series) -> str:\n    \"\"\"\n    Detect the most appropriate field type for a pandas Series.\n    Returns: 'DATE', 'DATETIME', 'NUMBER', or 'STRING'\n    \n    Optimized version using sampling and vectorized operations.\n    \"\"\"\n    # Remove null values for analysis\n    non_null_series = series.dropna()\n    \n    if len(non_null_series) == 0:\n        return \"STRING\"  # Default if all values are null\n    \n    # Use sampling for large datasets to improve performance\n    sample_size = min(10, len(non_null_series))  # Sample max 10 rows\n    if len(non_null_series) > sample_size:\n        sample_series = non_null_series.sample(n=sample_size, random_state=42)\n    else:\n        sample_series = non_null_series\n    \n    # Try numeric detection first (fastest check)\n    try:\n        # Use pandas to_numeric which is vectorized and much faster\n        pd.to_numeric(sample_series, errors='raise')\n        return \"NUMBER\"\n    except (ValueError, TypeError):\n        pass\n    \n    # Convert to string for pattern matching (only the sample)\n    string_series = sample_series.astype(str).str.strip()\n    \n    # Use vectorized regex operations for date/datetime detection\n    datetime_patterns = [\n        r'^\\d{4}-\\d{2}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2}$',  # YYYY-MM-DD HH:MM:SS\n        r'^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}',    # ISO format\n        r'^\\d{2}/\\d{2}/\\d{4}\\s\\d{2}:\\d{2}:\\d{2}$',  # MM/DD/YYYY HH:MM:SS\n    ]\n    \n    date_patterns = [\n        r'^\\d{4}-\\d{2}-\\d{2}$',        # YYYY-MM-DD\n        r'^\\d{2}/\\d{2}/\\d{4}$',        # MM/DD/YYYY\n        r'^\\d{2}-\\d{2}-\\d{4}$',        # MM-DD-YYYY\n        r'^\\d{1,2}/\\d{1,2}/\\d{4}$',    # M/D/YYYY\n    ]\n    \n    # Check datetime patterns first (more specific) using vectorized operations\n    for pattern in datetime_patterns:\n        matches = string_series.str.match(pattern, na=False)\n        match_ratio = matches.sum() / len(string_series)\n        if match_ratio >= 0.8:  # 80% threshold\n            return \"DATETIME\"\n    \n    # Check date patterns using vectorized operations\n    for pattern in date_patterns:\n        matches = string_series.str.match(pattern, na=False)\n        match_ratio = matches.sum() / len(string_series)\n        if match_ratio >= 0.8:  # 80% threshold\n            return \"DATE\"\n    \n    # Default to STRING\n    return \"STRING\"\n\n\ndef get_field_config(field_type: str) -> Dict[str, Any]:\n    \"\"\"Get the appropriate field configuration for a given field type.\"\"\"\n    if field_type == \"STRING\":\n        return {\"multi_line\": False}\n    elif field_type == \"NUMBER\":\n        # Format not supported in seal module yet, skip for now\n        return {}\n    elif field_type == \"DATE\":\n        # Format not supported in seal module yet, skip for now\n        return {}\n    elif field_type == \"DATETIME\":\n        # Format not supported in seal module yet, skip for now\n        return {}\n    else:\n        return {}\n\n\ndef main():\n    print(\"Starting CSV template generation...\")\n    \n    try:\n        # Get the containing entity\n        containing_entity = seal.get_containing_entity()\n        entity_fields = containing_entity.get(\"fields\", {})\n        \n        # Check for required Template Type Name\n        template_type_name = entity_fields.get(\"Template Type Name\", {}).get(\"value\")\n        if not template_type_name:\n            raise Exception(\n                \"Template Type Name is required. Please set the 'Template Type Name' field \"\n                \"to specify which type should be used for the template.\"\n            )\n        \n        print(f\"Using template type: {template_type_name}\")\n        \n        # Get CSV files\n        csv_files_refs = entity_fields.get(\"CSV Files\", {}).get(\"value\", [])\n        if not csv_files_refs:\n            raise Exception(\n                \"No CSV files found. Please upload CSV files to the 'CSV Files' field.\"\n            )\n        \n        print(f\"Found {len(csv_files_refs)} CSV file(s)\")\n        \n        # Use the first CSV file for template generation\n        csv_file_ref = csv_files_refs[0]\n        csv_entity = seal.get_entity(ref=csv_file_ref)\n        csv_filename = csv_entity.get(\"title\", \"imported_data\")\n        \n        print(f\"Processing CSV file: {csv_filename}\")\n        \n        # Download the CSV file\n        csv_file_path = seal.download_file(ref=csv_file_ref)\n        \n        # Read CSV with pandas\n        try:\n            df = pd.read_csv(csv_file_path)\n        except Exception as e:\n            raise Exception(f\"Failed to read CSV file: {str(e)}\")\n        \n        if df.empty:\n            raise Exception(\"CSV file is empty\")\n        \n        if len(df.columns) == 0:\n            raise Exception(\"CSV file has no columns\")\n        \n        print(f\"CSV loaded: {len(df)} rows, {len(df.columns)} columns\")\n        print(f\"Columns: {list(df.columns)}\")\n        \n        # Detect field types for each column\n        column_types = {}\n        for column in df.columns:\n            field_type = detect_field_type(df[column])\n            column_types[column] = field_type\n            print(f\"Column '{column}' detected as {field_type}\")\n        \n        # Search for the template type\n        template_type_entities = seal.get_entities_by_title(template_type_name, exact=True)\n        if not template_type_entities:\n            raise Exception(\n                f\"Template type '{template_type_name}' not found. \"\n                f\"Please create a type with this exact title first.\"\n            )\n        \n        template_type_entity = template_type_entities[0]\n        template_type_id = template_type_entity[\"id\"]\n        \n        print(f\"Found template type: {template_type_id}\")\n        \n        # Check if there's an existing template\n        existing_template_refs = entity_fields.get(\"Template\", {}).get(\"value\", [])\n        existing_template = None\n        \n        if existing_template_refs:\n            existing_template_ref = existing_template_refs[0]\n            existing_template = seal.get_entity(ref=existing_template_ref)\n            print(f\"Found existing template: {existing_template['id']}\")\n        \n        # Determine if we should update existing template or create new one\n        should_update_existing = (\n            existing_template and \n            existing_template[\"status\"] == \"EDITABLE\"\n        )\n        \n        if should_update_existing:\n            print(\"Updating existing template...\")\n            template_entity = existing_template\n            template_id = template_entity[\"id\"]\n        else:\n            print(\"Creating new template...\")\n            # Generate template name based on CSV filename\n            template_name = f\"{csv_filename.replace('.csv', '')} Template\"\n            \n            # Create new template from type\n            template_entity = seal.create_template_from_type(\n                type_id=template_type_id,\n                title=template_name\n            )\n            \n            template_id = template_entity[\"id\"]\n            print(f\"Created new template: {template_id}\")\n            \n            # Update the Template reference field\n            seal.update_field_value(\"Template\", [{\"id\": template_id, \"version\": None}])\n        \n        # Get current template fields to avoid duplicates\n        current_template = seal.get_entity(entity_id=template_id)\n        current_fields = current_template.get(\"fields\", {})\n        \n        # Add fields for each CSV column in the exact order they appear in the CSV\n        fields_added = 0\n\n        # Use df.columns to preserve the exact order from the CSV file\n        for column_name in df.columns:\n            field_type = column_types[column_name]\n            field_config = get_field_config(field_type)\n            \n            # Check if field already exists\n            if column_name in current_fields:\n                print(f\"Field '{column_name}' already exists, skipping...\")\n                continue\n            \n            try:\n                # Use the correct parameters for add_field_to_entity\n                seal.add_field_to_entity(\n                    entity_id=template_id,\n                    field_name=column_name,\n                    field_type=field_type,\n                    field_value=None,\n                    **field_config  # Only contains supported parameters now\n                )\n                fields_added += 1\n                print(f\"Added field '{column_name}' as {field_type}\")\n                \n            except Exception as e:\n                print(f\"Failed to add field '{column_name}': {str(e)}\")\n                continue\n        \n        print(f\"Template generation complete!\")\n        print(f\"- Template ID: {template_id}\")\n        print(f\"- Fields added: {fields_added}\")\n        print(f\"- Total columns processed: {len(df.columns)}\")\n        \n        if should_update_existing:\n            print(\"Note: Existing template was updated. You may need to publish it before importing data.\")\n        else:\n            print(\"Note: New template created. You may need to publish it before importing data.\")\n        \n    except Exception as e:\n        print(f\"Error: {str(e)}\")\n        raise\n\nmain()\n"
    }
  }
}